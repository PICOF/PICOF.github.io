<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分治解决二进制逆位问题</title>
    <url>/2021/03/30/1/</url>
    <content><![CDATA[<p> <a href="1/van.jfif">van.jfif</a> </p>
<h2 id="190、颠倒二进制位"><a href="#190、颠倒二进制位" class="headerlink" title="190、颠倒二进制位"></a><strong>190、颠倒二进制位</strong></h2><blockquote>
<p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p>提示：</p>
<p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p>
<p>进阶:<br>如果多次调用这个函数，你将如何优化你的算法？</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入: 00000010100101000001111010011100<br>输出: 00111001011110000010100101000000<br>解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。<br>示例 2：</p>
<p>输入：11111111111111111111111111111101<br>输出：10111111111111111111111111111111<br>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。<br>示例 1：</p>
<p>输入：n = 00000010100101000001111010011100<br>输出：964176192 (00111001011110000010100101000000)<br>解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。<br>示例 2：</p>
<p>输入：n = 11111111111111111111111111111101<br>输出：3221225471 (10111111111111111111111111111111)<br>解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</p>
<p>提示：</p>
<ul>
<li>输入是一个长度为 32 的二进制字符串</li>
</ul>
</blockquote>
<p>首先想到位运算绝壁不难，（然后就推不动了）再套用一个循环，把每次移位操作后的二进制数累加，很容易就得到了结果。</p>
<p>不过问题就在于——总会有一些沙雕面试官给你提出一些奇奇怪怪的问题，比如：如果不使用循环，此题该如何解答？</p>
<p><img src="/2021/03/30/1/%E5%81%9A%E4%BA%8B.jpeg" alt="做事"></p>
<h5 id="可以说是非常适合治疗低血压了"><a href="#可以说是非常适合治疗低血压了" class="headerlink" title="可以说是非常适合治疗低血压了"></a>可以说是非常适合治疗低血压了</h5><p>于是带着懵逼，我找到了这样一种神奇地不讲道理的解法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> M1 = <span class="number">0x55555555</span>;  <span class="comment">// 01010101010101010101010101010101</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> M2 = <span class="number">0x33333333</span>;  <span class="comment">// 00110011001100110011001100110011</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> M4 = <span class="number">0x0f0f0f0f</span>;  <span class="comment">// 00001111000011110000111100001111</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> M8 = <span class="number">0x00ff00ff</span>;  <span class="comment">// 00000000111111110000000011111111</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    n = n &gt;&gt; <span class="number">1</span> &amp; M1 | (n &amp; M1) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    n = n &gt;&gt; <span class="number">2</span> &amp; M2 | (n &amp; M2) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    n = n &gt;&gt; <span class="number">4</span> &amp; M4 | (n &amp; M4) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    n = n &gt;&gt; <span class="number">8</span> &amp; M8 | (n &amp; M8) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">return</span> n &gt;&gt; <span class="number">16</span> | n &lt;&lt; <span class="number">16</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是个分治算法（应该算吧），通过不断对n进行二分交换，最后达到完全倒序的效果（不信可以试一试，确实倒序了），期间对多个十六进制数进行的与运算是为了保留特定位数上的二进制信息，或运算则是将每次的两半结果叠加，最后返回的即是倒序数列。可以看出这个做法的时间复杂度只有O(1)，比循环更优。</p>
<p>对了，关于位运算这里填一个传送门：</p>
<p><a href="https://www.cnblogs.com/yrjns/p/11246163.html">https://www.cnblogs.com/yrjns/p/11246163.html</a></p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>进制转换</tag>
        <tag>分治</tag>
        <tag>位运算</tag>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title>132模式</title>
    <url>/2021/03/24/132/</url>
    <content><![CDATA[<p><em>这道题主要涉及到了单调栈的运用，我还不是很熟悉这一类题型</em></p>
<h3 id="题干"><a href="#题干" class="headerlink" title="题干:"></a><strong>题干:</strong></h3><blockquote>
<p>给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i &lt; j &lt; k 和 nums[i] &lt; nums[k] &lt; nums[j] 。</p>
<p>如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。</p>
<p>进阶：很容易想到时间复杂度为 O(n^2) 的解决方案，你可以设计一个时间复杂度为 O(n logn) 或 O(n) 的解决方案吗？</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：nums = [1,2,3,4]<br>输出：false<br>解释：序列中不存在 132 模式的子序列。<br>示例 2：</p>
<p>输入：nums = [3,1,4,2]<br>输出：true<br>解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。<br>示例 3：</p>
<p>输入：nums = [-1,3,2,0]<br>输出：true<br>解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</p>
<p>提示：</p>
<ul>
<li>n == nums.length</li>
<li>1 &lt;= n &lt;= 104</li>
<li>-109 &lt;= nums[i] &lt;= 109</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/132-pattern">https://leetcode-cn.com/problems/132-pattern</a></p>
</blockquote>
<p>读完后第一反应是找一些方便判断的特征，找到对应的候选数字后不断进行维护。。。然后运行的时间复杂度是O（n^2）,而且在写代码时让人非常不舒服，过程过于繁杂且容易出错。</p>
<p>所以这里我们引入单调栈，即用栈存储数据，且栈内数据一定是单增（或单减），一旦遇到下一个数就立马用其与栈内元素比较，大于（或小于）的元素则全部出栈，最后将新的数压栈。</p>
<p>对于这道题，我们用单减的单调栈，即栈内元素中一定存在代表132模式中“3”的元素，而出栈元素用一个max变量维护，保证max对应132中“2”的候选元素中的最大值。此时，只要新的元素小于max，即可返回true（即新元素为132模式中代表“1”的元素）</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(numsSize&lt;<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">stack</span>[numsSize];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nu=<span class="number">0</span>,max=<span class="number">-1000000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">stack</span>[nu++]=nums[numsSize<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=numsSize<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(nums[i]&lt;max)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">int</span> j=nu<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(<span class="built_in">stack</span>[j]&lt;nums[i])&#123;</span><br><span class="line"></span><br><span class="line">​    nu--;</span><br><span class="line"></span><br><span class="line">​    max=<span class="built_in">stack</span>[j];</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">stack</span>[nu++]=nums[i];</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如下图解：</strong></p>
<p><img src="/2021/03/24/132/132.png" alt="132模式"></p>
<p>这里还有一篇关于单调栈的文章，写的很好，放个链接在这里：</p>
<p><a href="https://blog.csdn.net/weixin_42784951/article/details/88963758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161659419116780262549524%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161659419116780262549524&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-88963758.pc_search_result_cache&amp;utm_term=%E5%8D%95%E8%B0%83%E6%A0%88">https://blog.csdn.net/weixin_42784951/article/details/88963758?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161659419116780262549524%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=161659419116780262549524&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-2-88963758.pc_search_result_cache&amp;utm_term=%E5%8D%95%E8%B0%83%E6%A0%88</a></p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题目</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>坑爹的 EOF</title>
    <url>/2021/06/02/EOF/</url>
    <content><![CDATA[<p><img src="/2021/06/02/EOF/cover.JPG" alt="cover"><em>起因是这样的，在完成 C++ 期末项目的时候，好不容易编译成功了，结果实际运行的时候文件读取出了幺蛾子……明明是一模一样的代码，用 IDE 跑一点事没有，然而一到 Linux 下运行内部链表都给我扬了……</em></p>
<span id="more"></span>

<p><strong>错误原因：</strong></p>
<p>找 bug 的过程异常痛苦，一开始完全没有头绪，只知道肯定是读入时出了问题——可是我文件读入的函数写的简直标准（CV 大法），想来想去还是抱着试一试的心态查了一下 <strong>EOF</strong> 相关的 bug</p>
<p>结果和我遇到相同状况的人还挺多，确实是 <strong>EOF</strong> 判断机制上的问题。</p>
<p>我们主观认为读到最后一个字符就会停止，但实际上我们判断读取完成是由一个叫 <strong>eofbit</strong> 的东西来判断的，当读取到最后一个字符时，<strong>eofbit</strong> 并不会置为 <strong>false</strong> ，而是保持 <strong>true</strong> 状态接着向下确认后才置为 <strong>false</strong>。</p>
<p><strong>解决方法：</strong></p>
<p><strong>1、</strong>使用 <strong>peek( )</strong> 将指针后移。</p>
<p><strong>2、</strong>增加判断语句，改变结构：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//xxxxxxxxxxxx</span></span><br><span class="line">	read the file;</span><br><span class="line">    <span class="comment">//xxxxxxxxxxxx</span></span><br><span class="line"><span class="keyword">if</span>(feof(fpsr))</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//退出循环</span></span><br><span class="line">	<span class="comment">//xxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line">    operation to the file;</span><br><span class="line">    <span class="comment">//xxxxxxxxxxxxxxxxxxxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的语法可以在最后多读取的那一次进行操作之前再进行一次 <strong>eof</strong> 判断来及时退出循环。</p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>文件操作</tag>
        <tag>被坑</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>I love jwjj</title>
    <url>/2021/03/09/I-love-jwjj/</url>
    <content><![CDATA[<h1 id="jwjj-I-love-you"><a href="#jwjj-I-love-you" class="headerlink" title="jwjj,I love you"></a>jwjj,I love you</h1>]]></content>
      <categories>
        <category>对jwjj的爱</category>
      </categories>
      <tags>
        <tag>jwjj</tag>
        <tag>爱</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie前缀树</title>
    <url>/2021/04/14/Trie%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<p><img src="/2021/04/14/Trie%E5%89%8D%E7%BC%80%E6%A0%91/cover.jpg" alt="cover"></p>
<span id="more"></span>

<h3 id="一、题干："><a href="#一、题干：" class="headerlink" title="一、题干："></a>一、题干：</h3><blockquote>
<h4 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[<span class="string">&quot;Trie&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;search&quot;</span>, <span class="string">&quot;search&quot;</span>, <span class="string">&quot;startsWith&quot;</span>, <span class="string">&quot;insert&quot;</span>, <span class="string">&quot;search&quot;</span>]</span><br><span class="line">[[], [<span class="string">&quot;apple&quot;</span>], [<span class="string">&quot;apple&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>], [<span class="string">&quot;app&quot;</span>]]</span><br><span class="line">输出</span><br><span class="line">[null, null, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, null, <span class="literal">true</span>]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">trie.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">trie.search(<span class="string">&quot;apple&quot;</span>);   <span class="comment">// 返回 True</span></span><br><span class="line">trie.search(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 False</span></span><br><span class="line">trie.startsWith(<span class="string">&quot;app&quot;</span>); <span class="comment">// 返回 True</span></span><br><span class="line">trie.insert(<span class="string">&quot;app&quot;</span>);</span><br><span class="line">trie.search(<span class="string">&quot;app&quot;</span>);     <span class="comment">// 返回 True</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>
<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li>
</ul>
</blockquote>
<h3 id="二、关于前缀树："><a href="#二、关于前缀树：" class="headerlink" title="二、关于前缀树："></a>二、关于前缀树：</h3><p>前缀树又被称为字典树，是一种树状数据结构，可以存储字符串集合，尤其对于相同前缀的字符串非常友好</p>
<p>这一高效的数据结构有多种应用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>自动补全</span><br><span class="line"><span class="number">2.</span>拼写检查</span><br><span class="line"><span class="number">3.</span>IP 路由 (最长前缀匹配)</span><br><span class="line"><span class="number">4.</span>打字预测</span><br></pre></td></tr></table></figure>

<p><strong>存储方式：</strong></p>
<p><img src="/2021/04/14/Trie%E5%89%8D%E7%BC%80%E6%A0%91/tree.bmp" alt="tree"></p>
<p>根节点上存储的全都是某几个字符串的公共字符，因此便于查找前缀。每一个节点里都是一个字符元素。在与哈希表相似的原理支持下，按字符搜索可以将其复杂度降低至O（n）<em>（这里n是字符串长度）</em>平衡二叉树复杂度为O（logn），可见在字符串的长度较小时前缀树更为合适。</p>
<p><strong>实现：</strong></p>
<p>具体实现方式其实有两种——<strong>1、用数组</strong>实现和<strong>2、用Hash Map</strong>实现。</p>
<p>数组解法基本思路是每个节点用一个长度26的数组储存该节点字符情况，并用一个bool数值判断是否到达末尾（即后续无字符节点）。</p>
<h3 id="代码（数组）："><a href="#代码（数组）：" class="headerlink" title="代码（数组）："></a><strong>代码（数组）：</strong></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>* <span class="title">wd</span>[26];</span></span><br><span class="line">  <span class="keyword">bool</span> end;<span class="comment">//判断是否为单词结尾的bool值</span></span><br><span class="line">&#125; Trie;</span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function">Trie* <span class="title">trieCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Trie* p=(Trie*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Trie));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">​    p-&gt;wd[i]=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;end=<span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trieInsert</span><span class="params">(Trie* obj, <span class="keyword">char</span> * word)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(word);i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(obj-&gt;wd[word[i]<span class="number">-97</span>]==<span class="literal">NULL</span>)&#123;</span><br><span class="line">​     Trie* p=trieCreate();</span><br><span class="line">​     obj-&gt;wd[word[i]<span class="number">-97</span>]=p;<span class="comment">//利用关键字进行匹配比对</span></span><br><span class="line">   &#125;</span><br><span class="line">   obj=obj-&gt;wd[word[i]<span class="number">-97</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> obj-&gt;end=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">trieSearch</span><span class="params">(Trie* obj, <span class="keyword">char</span> * word)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(word);i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(obj-&gt;wd[word[i]<span class="number">-97</span>]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">​     obj=obj-&gt;wd[word[i]<span class="number">-97</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">​     <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//返回的是最后匹配节点的bool值</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> obj-&gt;end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">trieStartsWith</span><span class="params">(Trie* obj, <span class="keyword">char</span> * prefix)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(prefix);i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(obj-&gt;wd[prefix[i]<span class="number">-97</span>]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">​     obj=obj-&gt;wd[prefix[i]<span class="number">-97</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">​     <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trieFree</span><span class="params">(Trie* obj)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> \* Your Trie struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> \* Trie* obj = trieCreate();</span></span><br><span class="line"><span class="comment"> \* trieInsert(obj, word);</span></span><br><span class="line"><span class="comment"> \* bool param_2 = trieSearch(obj, word);</span></span><br><span class="line"><span class="comment"> \* bool param_3 = trieStartsWith(obj, prefix);</span></span><br><span class="line"><span class="comment"> \* trieFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>搜索字符串和前缀的方式相近，都是随节点向下匹配，只不过字符串要考虑当前是否为末尾（bool值判定）</p>
<h3 id="Hash-Map方法："><a href="#Hash-Map方法：" class="headerlink" title="Hash Map方法："></a>Hash Map方法：</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>上面的方法预先对每个节点设置了一个长为26的数组，浪费空间。我们可以使用字典来实现。</p>
<p>对于每个节点都是一个字典dict， <strong>它的键为后续的字符，值为这个字符对应的字典，同时对单词结尾的字符，我们添加一个键-1，如果-1在这个字典中，说明这个单词存在。整个结构相当于一层一层嵌套的字典，所以叫字典树。</strong></p>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/JUandjuddd/article/details/110095650">Trie 前缀树原理及两种实现</a></p>
<p><a href="https://blog.csdn.net/xuexiaoyaani/article/details/79808338">数据结构之字典</a></p>
<p><a href="https://www.cnblogs.com/hengzhezou/p/11046886.html">字典树（前缀树）的实现</a></p>
]]></content>
      <categories>
        <category>程序算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>题目</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>ch2线性表总结</title>
    <url>/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/nice.jpg" alt="nice"></p>
<span id="more"></span>

<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/a.png" alt="a"></p>
<blockquote>
<p>☺<strong>线性表（Linear List）是由n (n≥0)个类型相同的数据元素a1,a2,…，an组成的有限序列，记做（a1,a2,…，ai-1，ai，ai+1， …，an）。</strong><br><strong>数据元素之间是一对一的关系，即每个数据元素最多有一个直接前驱和一个直接后继。</strong></p>
<p>☺<strong>线性表（Linear List）是由n (n≥0)个类型相同的数据元素a1,a2,…，an组成的有限序列，记做（a1,a2,…，ai-1，ai，ai+1， …，an）。</strong><br><strong>数据元素之间是一对一的关系，即每个数据元素最多有一个直接前驱和一个直接后继。</strong></p>
</blockquote>
<h3 id="实际上，链表就是一种典型的线性表（链式储存）。"><a href="#实际上，链表就是一种典型的线性表（链式储存）。" class="headerlink" title="实际上，链表就是一种典型的线性表（链式储存）。"></a><code>实际上，链表就是一种典型的线性表（链式储存）。</code></h3><blockquote>
<p>线性表的三个特点：</p>
<ul>
<li>同一性：线性表由同类数据元素组成，每一个ai必须属于同一数据对象。</li>
<li>有穷性：线性表由有限个数据元素组成，表长度就是表中数据元素的个数。</li>
<li>有序性：线性表中相邻数据元素之间存在着 序偶关系&lt;ai,ai+1&gt;。</li>
</ul>
</blockquote>
<h3 id="一、线性表的顺序存储："><a href="#一、线性表的顺序存储：" class="headerlink" title="一、线性表的顺序存储："></a>一、线性表的顺序存储：</h3><p>简单来讲，数组就算是顺序储存，在编程学习过程中，我们之前提到了数组加法的定义——下标向后改变指向，实际上就是因为顺序储存的物理相邻状态与逻辑相邻状态一致。</p>
<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/b.png" alt="b"></p>
<p>顺序操作的基本运算如下：</p>
<p>☺<strong>查找操作：</strong> 两种：1、按序号和2、按内容，选取哪一种主要取决于得到的相关信息是什么。</p>
<p>☺<strong>插入操作：</strong> 相比链式存储而言，顺序表的插入显得非常繁琐，为了在中间插入某个数往往需要将其后的数全部依次后移。</p>
<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/c.png" alt="c"></p>
<p>注意这里k–是为了避免出现数据覆盖的情况而从后向前依次进行移位操作。</p>
<p>其实讲道理，这种插入操作本身也算一种“原地算法”。算法分析如下：</p>
<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/d.png" alt="d"></p>
<p>☺<strong>删除操作：</strong>讲道理和上面插入其实一样的，因此算法复杂度也都是O(n)。</p>
<p>☺<strong>顺序表合并算法：</strong></p>
<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/e.png" alt="e"></p>
<blockquote>
<p>☺<strong>算法思想</strong> <strong>：</strong></p>
<p>♫设表LC是一个空表，设两个指针i、j分别指向表LA和LB中的元素，<br>♫若LA.elem[i]&gt;LB.elem[j]，则当前先将LB.elem[j]插入到表LC中，<br>♫若LA.elem[i]≤LB.elem[j] ，当前先将LA.elem[i]插入到表LC中，<br>♫如此进行下去，直到其中一个表被扫描完毕，然后再将未扫描完的表中剩余的所有元素放到表LC中。</p>
<p><em>因此算法的时间复杂度其实就和两表长度和有关</em></p>
</blockquote>
<p>其实也完全可以先直接一股脑全部塞进去，再利用qsort（）函数进行排序（从懒得写代码的角度来说我其实更喜欢这个）。</p>
<h4 id="顺序存储总结："><a href="#顺序存储总结：" class="headerlink" title="顺序存储总结："></a><strong>顺序存储总结：</strong></h4><p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/f.png" alt="f"></p>
<p>顺序储存固然方便，但同时也存在诸多不足。因此，在一些特定情况下，顺序存储显然已不能满足要求，此时就需要用到链式存储。</p>
<h3 id="二、线性表的链式存储："><a href="#二、线性表的链式存储：" class="headerlink" title="二、线性表的链式存储："></a>二、线性表的链式存储：</h3><p>☺<strong>采用链式存储结构的线性表称为链表</strong> <strong>。</strong></p>
<p>☺<strong>每个节点包含指针域（存放位置）和数据域（存放结点的值）</strong> </p>
<p>☺<strong>设计链式存储结构时，每个逻辑结点存储单独存储，为了表示逻辑关系，增加指针域。</strong> </p>
<p><em>（物理上不一定相连，是由指针域来保持逻辑关系上相连的）</em></p>
<p>仅有后继节点的是单链表，而多一个前驱节点则成为了双链表</p>
<p>（附上一个不错的简述：<a href="https://blog.csdn.net/SlimShadyKe/article/details/89503062?spm=1001.2014.3001.5506%EF%BC%89">https://blog.csdn.net/SlimShadyKe/article/details/89503062?spm=1001.2014.3001.5506）</a></p>
<blockquote>
<p><strong>为什么要添加头节点，有什么优点：</strong></p>
<ul>
<li>第一个结点的操作和表中其他结点的操作相一致，无需进行特殊处理；</li>
<li>无论链表是否为空，都有一个头结点，因此空表和非空表的处理也就统一了。</li>
</ul>
</blockquote>
<p>对于链表的初始化和插入删除等操作，这里有一个较为详细的教程：</p>
<p><a href="https://blog.csdn.net/swag_wg/article/details/89673850?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;dist_request_id=1328769.68644.16176667858667719&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/swag_wg/article/details/89673850?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=1328769.68644.16176667858667719&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>
<p>注：查找无论是按序号还是按值，都必须确认当前是否处于一个合法的位置（即判断是否越界，检查是否为NULL），不同点在于一个加了计数器辅助，另一个用值域做筛选。</p>
<p>计算长度和按序号查找加入计数器的方法类似。</p>
<h4 id="循环链表："><a href="#循环链表：" class="headerlink" title="循环链表："></a>循环链表：</h4><blockquote>
<p><strong>与非循环单链表相比，循环单链表：</strong></p>
<ol>
<li>链表中没有空指针域</li>
<li>p所指结点为尾结点的条件：p-&gt;next==L（头节点）</li>
</ol>
</blockquote>
<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/g.png" alt="g"></p>
<p>由此可见带尾结点的链表结构在进行一些运算时比仅有头指针的链表表现更优（查找，合并等操作），比如：</p>
<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/i.png" alt="i"><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/h.png" alt="h"></p>
<h4 id="双向链表："><a href="#双向链表：" class="headerlink" title="双向链表："></a>双向链表：</h4><p>相比单向链表，既有后继节点又有前驱节点，从任一结点出发可以访问其他结点。</p>
<p>对应的，也有<strong>双向循环链表</strong>。</p>
<p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/j.png" alt="j"></p>
<h4 id="链式存储总结："><a href="#链式存储总结：" class="headerlink" title="链式存储总结："></a>链式存储总结：</h4><p><img src="/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/k.png" alt="k"></p>
<p><em>下一单元总结链接：<a href="https://picof.github.io/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">ch3栈和队列</a></em></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>课内总结</tag>
        <tag>学习</tag>
        <tag>线性表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>ch3栈和队列</title>
    <url>/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><img src="/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/cover.JPG" alt="cover"></p>
<p><em>学不会的时候，只要微笑就好了</em></p>
<span id="more"></span>

<p><em>上一单元总结链接：<a href="https://picof.github.io/2021/04/06/ch2%E7%BA%BF%E6%80%A7%E8%A1%A8%E6%80%BB%E7%BB%93/">ch2线性表总结</a></em></p>
<h3 id="一、栈："><a href="#一、栈：" class="headerlink" title="一、栈："></a>一、栈：</h3><p>☺<strong>栈是一种只能在一端进行插入或删除操作的线性表。</strong></p>
<p>☺<strong>栈只能选取同一个端点进行插入和删除操作</strong></p>
<p><strong>定义：</strong></p>
<p>☺<strong>允许进行插入、删除操作的一端称为<em>栈顶</em>。</strong></p>
<p>☺<strong>表的另一端称为<em>栈底</em>。</strong></p>
<p>☺<strong>当栈中没有数据元素时，称为<em>空栈</em></strong>。</p>
<p>☺<strong>栈的插入操作通常称为<em>进栈</em></strong>或<em><strong>入栈</strong></em>。</p>
<p>☺<strong>栈的删除操作通常称为<em>退栈</em></strong>或<em><strong>出栈</strong></em>。</p>
<p>由于栈中元素之间的逻辑关系与线性表相同，所以可以采用和线性表相同的存储结构</p>
<p>【问】栈和堆有什么区别：<a href="https://blog.csdn.net/u012836896/article/details/89973820?spm=1001.2014.3001.5506">参考解释</a></p>
<ul>
<li><h3 id="1-1——顺序栈"><a href="#1-1——顺序栈" class="headerlink" title="1.1——顺序栈"></a><em>1.1——<strong>顺序栈</strong></em></h3></li>
</ul>
<p><img src="/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/a.png" alt="a"></p>
<p><strong>两栈共享：</strong></p>
<p><img src="/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/b.png" alt="b"></p>
<p>从两端同时开始操作</p>
<ul>
<li><h3 id="1-2——链栈"><a href="#1-2——链栈" class="headerlink" title="1.2——链栈"></a><em>1.2——<strong>链栈</strong></em></h3></li>
</ul>
<p><strong>首先明确：该方案采用的是头插法，判空机制是利用top-&gt;next是否为空指针。</strong></p>
<p><img src="/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/c.png" alt="c"></p>
<p>将多个链栈的栈顶指针放在一个一维数组里来统一管理，从而实现管理和使用多个栈，叫做多栈运算，而<em><strong>哈希表</strong></em>就是其经典使用案例。</p>
<p>栈的应用举例：☺<strong>表达式求值：无括号算术表达式求值（详情可以看一下我的<a href="https://picof.github.io/2021/03/16/%E9%80%86%E6%B3%A2%E5%85%B0/">另一篇转载内容</a>）</strong></p>
<ul>
<li><h3 id="1-3-栈与递归的实现："><a href="#1-3-栈与递归的实现：" class="headerlink" title="1.3 栈与递归的实现："></a><em>1.3 栈与递归的实现：</em></h3></li>
</ul>
<p>递归就像套娃，经过层层调用到最底层的数值，再利用他一层层回来求更复杂的值；比如斐波那契数列就是一个典型的有递归特性的数列。</p>
<p>教材上举例用了汉诺塔，但是光给了代码，说明不是很清楚。首先我们看一下四个环时该怎么移动……</p>
<p><img src="/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/hannuo.gif" alt="hannuo"></p>
<p><em>（来源于网络，侵删）</em></p>
<p>相信聪明如你肯定幼儿园就已经看破了，那么其实五个环甚至更多的环操作都是一样的：移动n个环，其实只要把最大的——即第n个环先看作底座的一部分不去理会，剩下n-1个环按n-1的方法去移动，最后再考虑多出的第n个环——以此类推，这其实就是不断调用前项的结果的递归算法。</p>
<p>不过既然每次计算都会向前不断自身调用，递归算法的耗时也是异常地感人……</p>
<h3 id="二、队列："><a href="#二、队列：" class="headerlink" title="二、队列："></a><strong>二、队列：</strong></h3><ul>
<li><h3 id="2-1-简单定义："><a href="#2-1-简单定义：" class="headerlink" title="2.1 简单定义："></a><em>2.1 简单定义：</em></h3></li>
</ul>
<p><img src="/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/d.png" alt="d"></p>
<p>相对于栈单进单出，先进后出；队列一般是先进先出</p>
<p>不过对于队列，元素往往是从尾巴上怼进去的</p>
<blockquote>
<ul>
<li>把进行插入的一端称做<strong>队尾（rear）</strong>。</li>
<li>进行删除的一端称做<strong>队首</strong>或<strong>队头（front）</strong>。</li>
<li>向队列中插入新元素称为<strong>进队</strong>或<strong>入队</strong>，新元素进队后就成为新的队尾元素。</li>
<li>从队列中删除元素称为<strong>出队</strong>或<strong>离队</strong>，元素出队后，其后继元素就成为队首元素。</li>
<li>队列具有<strong>先进先出</strong> (Fist In Fist Out，缩写为<em><strong>FIFO</strong></em>)的特性</li>
</ul>
</blockquote>
<p><img src="/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/e.png" alt="e"></p>
<h3 id="2-2-队列的表示与实现："><a href="#2-2-队列的表示与实现：" class="headerlink" title="2.2 队列的表示与实现："></a><em>2.2 队列的表示与实现：</em></h3><p>逻辑关系上仍与线性表相同，故仍可用<em><strong>1、顺序队列</strong></em>和<em><strong>2、链队列</strong></em>两种存储结构</p>
<h4 id="循环链表："><a href="#循环链表：" class="headerlink" title="循环链表："></a><strong>循环链表：</strong><img src="/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/f.png" alt="f"></h4><p>这里通过取模使得下标数值永远不超过最大下标值。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>课内总结</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>ch4串</title>
    <url>/2021/04/25/ch4%E4%B8%B2/</url>
    <content><![CDATA[<img src="/2021/04/25/ch4%E4%B8%B2/cover.PNG" alt="cover" style="zoom: 50%;">

<p><em>新的一篇总结，较为简陋，主要是因为核心内容KMP算法之前就写过了</em></p>
<span id="more"></span>

<p><em>上一单元总结传送门：<a href="https://picof.github.io/2021/04/13/ch3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">ch3栈和队列</a></em></p>
<h3 id="串的基本概念："><a href="#串的基本概念：" class="headerlink" title="串的基本概念："></a>串的基本概念：</h3><p><img src="/2021/04/25/ch4%E4%B8%B2/a.png" alt="a"></p>
<blockquote>
<p>☺<strong>子串</strong>：一个串中任意个连续字符组成的子序列（含空串）称为该串的子串。</p>
<p>☺<strong>真子串</strong>：是指不包含自身的所有子串。</p>
<p>☺<strong>主串</strong>：包含子串的串称为主串。</p>
<p>☺<strong>空串</strong>： <strong>n=0</strong>时的串为空串**(Null String)**。</p>
<p>☺<strong>空格串</strong>：<strong>’ ’</strong></p>
<p>☺<strong>例如，‘abcde’的子串有：</strong></p>
<p>♫<strong>‘’</strong>、<strong>‘a’</strong>、<strong>‘ab’</strong>、<strong>‘abc’</strong>、<strong>‘abcd’</strong>和‘<strong>abcde’</strong>等</p>
</blockquote>
<p>注意空串和空格串别搞混了就行</p>
<ul>
<li>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象约束为<strong>字符集</strong>。</li>
<li>串的基本操作和线性表有很大差别：<br>在线性表的基本操作中，大多以“<strong>单个元素</strong>”作为操作对象；<br>在串的基本操作中，通常以“<strong>串的整体</strong>”作为操作对象。</li>
</ul>
<h3 id="串的不同储存实现方法："><a href="#串的不同储存实现方法：" class="headerlink" title="串的不同储存实现方法："></a>串的不同储存实现方法：</h3><p>无非就是<strong>静态</strong>（<em>顺序串</em>）卡死长度与内存，或者换用<strong>动态</strong>（<em>堆串、块链串</em>）调用堆栈一类来分配内存。</p>
<p><strong>定长型代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 40</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>   <span class="comment">/*串结构定义*/</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125; SString; </span><br><span class="line"><span class="comment">//仍然是设计成结构类型，但是长度早在编译时就确定了</span></span><br></pre></td></tr></table></figure>

<p><strong>堆串代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;	<span class="comment">//若是非空串，按串长分配空间，否则ch为NULL</span></span><br><span class="line">    <span class="keyword">int</span> length;	<span class="comment">//串长</span></span><br><span class="line">&#125; <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">/*这种存储方法以一组地址连续的存储单元存放串的字符序列，但它们的存储空间是在程序执行过程中动态分配的。</span></span><br><span class="line"><span class="comment">系统将一个地址连续、容量很大的存储空间作为字符串的可用空间，每当建立一个新串时，系统就从这个空间中分配一个大小和字符串长度相同的空间存储新串的串值。 </span></span><br><span class="line"><span class="comment">在C语言中，存在一个称为“堆”的自由空间，由动态分配函数malloc( )分配一块实际串长所需的存储空间，如果分配成功，则返回这段空间的起始地址，作为串的基址。由free( )释放串不再需要的空间。*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/25/ch4%E4%B8%B2/b.png" alt="b"></p>
<p><strong>块链串代码：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  BLOCK_SIZE  4  <span class="comment">/*每结点存放字符个数*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[BLOCK_SIZE];	 <span class="comment">/*BLOCK_SIZE为1，就是单链表结构*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block</span>   *<span class="title">next</span>;</span></span><br><span class="line">&#125; Block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Block   *head;</span><br><span class="line">    Block   *tail; 	<span class="comment">/* tail联接2个串使用*/</span></span><br><span class="line">    <span class="keyword">int</span>     length;</span><br><span class="line">&#125; BLString; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/25/ch4%E4%B8%B2/c.jpg" alt="c"></p>
<h3 id="存储密度："><a href="#存储密度：" class="headerlink" title="存储密度："></a>存储密度：</h3><p>☺ <strong>“存储密度”= 结点数据本身占用的空间 / 结点占用的空间总量</strong>  </p>
<p>☺ <strong>存储密度小</strong>（如节点大小为1时，每个结点存放一个字符），运算处理方便，但存储占用量大。</p>
<p>☺ <strong>存储密度大</strong>，当一个块内存放多个字符时，往往使操作过程变的较为复杂，如在串中插入一个字符或删除一个字符，通常需要将字符在块间移动。</p>
<p><em>之前的定长串显然是储存密度最大的，但是相对的，对它的操作往往比另外两种存储方式繁琐的多。</em></p>
<h3 id="串的匹配模式："><a href="#串的匹配模式：" class="headerlink" title="串的匹配模式："></a>串的匹配模式：</h3><p>这点请移步至我之前写的 <em><a href="https://picof.github.io/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/">数据结构KMP算法</a></em> 这篇博客进行详细了解</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>课内总结</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>ch5数组和广义表</title>
    <url>/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/</url>
    <content><![CDATA[<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/cover.JPG" alt="cover"></p>
<p>相当不妙……马上就要期末考试了……我还有一堆事情，总之先搞一下总结。</p>
<span id="more"></span>

<p>上一单元总结：*<a href="https://picof.github.io/2021/04/25/ch4%E4%B8%B2/#more">ch4串 | PICOF’s blog</a>*</p>
<h2 id="5-1、数组的定义和运算"><a href="#5-1、数组的定义和运算" class="headerlink" title="5.1、数组的定义和运算"></a>5.1、数组的定义和运算</h2><h3 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h3><p>☺<strong>数组是一种数据类型。</strong></p>
<p>☺<strong>从 <em>逻辑结构</em> 上看，数组可以看成是一般 <em>线性表</em> 的扩充。</strong></p>
<p>☺<strong>二维数组可以看成是线性表的线性表。</strong>（就是把多个不同子线性表理解成元素放入大线性表中）</p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/a.png" alt="a"></p>
<p>按照上面的逻辑，我们可以向 N 维度不断类推，即 N 维数组是数据元素为 N-1 维数组的线性表。</p>
<h3 id="2、运算："><a href="#2、运算：" class="headerlink" title="2、运算："></a>2、运算：</h3><p>☺ <strong>数组是一组有固定个数的元素的集合。</strong></p>
<p>☺ <strong>对数组的  <em>操作</em>  不象对线性表的操作那样，可以在表中任意一个合法的位置插入或删除一个元素。</strong></p>
<p>☺ <strong>对于数组的操作一般只有两类：</strong></p>
<p>♫ <strong>获得特定位置</strong>的元素值；</p>
<p>♫ <strong>修改特定位置</strong>的元素值。</p>
<p>这里的运算实质上就牵扯到存放数据的地址计算问题了。</p>
<h3 id="3、数组的抽象数据类型定义："><a href="#3、数组的抽象数据类型定义：" class="headerlink" title="3、数组的抽象数据类型定义："></a>3、数组的抽象数据类型定义：</h3><p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/b.png" alt="b"></p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/c.png" alt="c"></p>
<h2 id="5-2、数组的顺序存储与实现："><a href="#5-2、数组的顺序存储与实现：" class="headerlink" title="5.2、数组的顺序存储与实现："></a>5.2、数组的顺序存储与实现：</h2><p>数组不像链表一样，一般来说数组的基本操作是不会涉及结构的改变的（一般不会涉及插入、删除等链表类的操作，不涉及移动元素操作）。因此对于数组来说，顺序存储才是最合适的存储方法。</p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/d.png" alt="d"></p>
<blockquote>
<p>注：上图默认数组元素由 1 开始计数</p>
</blockquote>
<p>☺<strong>二维数组的顺序存储结构有两种：</strong></p>
<p>♫  <strong>一种是按行序存储，如高级语言 C、BASIC、COBOL 和 PASCAL 语言都是以行序为主。</strong></p>
<p>♫  <strong>另一种是按列序存储，如高级语言中的 FORTRAN 语言就是以列序为主。</strong></p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/e.png" alt="e"></p>
<blockquote>
<p><strong>n维数组地址计算：</strong></p>
<p><em>第一维主序：</em><br>LOC (j1, j2, … , jn ) = LOC (1, 1, … , 1) +<br>    [ b2*b3*…*bn*(j1 - 1) + b3*b4*…*bn*(j2 - 1) + … + bn*(jn-1 - 1)+ (jn - 1) ] * size</p>
</blockquote>
<h2 id="5-3-特殊矩阵的压缩存储"><a href="#5-3-特殊矩阵的压缩存储" class="headerlink" title="5.3 特殊矩阵的压缩存储"></a>5.3 特殊矩阵的压缩存储</h2><p>☺<strong>在高级程序设计语言里面，矩阵通常采用二维数组表示。</strong></p>
<p>☺特殊矩阵可采用 <strong>压缩存储</strong> 的方式</p>
<p>♫ 元素分布 <strong>有规律的矩阵</strong>，按规律实现压缩储存</p>
<p>♫ <strong>非零元素少</strong> 的稀疏矩阵，采用 <strong>存非零元素</strong> 实现压缩存储</p>
<h3 id="5-3-1、分布规律的特殊矩阵"><a href="#5-3-1、分布规律的特殊矩阵" class="headerlink" title="5.3.1、分布规律的特殊矩阵"></a>5.3.1、分布规律的特殊矩阵</h3><h4 id="1、三角矩阵："><a href="#1、三角矩阵：" class="headerlink" title="1、三角矩阵："></a>1、三角矩阵：</h4><p>☺ 三角矩阵（ n阶矩阵）</p>
<ul>
<li>下三角矩阵：若当 i &lt; j 时，有aij=0</li>
<li>上三角矩阵：若当 i &gt; j 时，有aij=0</li>
<li>对称矩阵：若矩阵中的所有元素均满足 aij = aji </li>
</ul>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/f.png" alt="f"></p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/g.png" alt="g"></p>
<h4 id="2、带状矩阵："><a href="#2、带状矩阵：" class="headerlink" title="2、带状矩阵："></a>2、带状矩阵：</h4><p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/h.png" alt="h"></p>
<p>☺ 三对角带状矩阵的压缩存储，以 <strong>行序为主序</strong> 进行存储，并且只存储非零元素</p>
<p>☺ 确定存储该矩阵所需的一维向量空间的大小</p>
<p>♫ 除第一行和最后一行只有两个元素外，其余各行均有 3 个非零元素。由此可得到一维向量所需的空间大小为：**3n-2 **</p>
<p>☺<strong>确定非零元素在一维数组空间中的位置</strong></p>
<blockquote>
<p>LOC[aij] = LOC[a11]+[3*(i-1)-1+j-i+1]*size<br>                  =LOC[a11]+[2(i-1)+j-1]*size</p>
</blockquote>
<h3 id="5-3-2、稀疏矩阵"><a href="#5-3-2、稀疏矩阵" class="headerlink" title="5.3.2、稀疏矩阵"></a>5.3.2、稀疏矩阵</h3><p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/i.png" alt="i"></p>
<p>由于这种矩阵毫无规律可循，也就没有和之前几个矩阵一样的公式或函数表达了。</p>
<p>为此我们采用了存储坐标和元素值的做法——即 <strong>三元组表示法</strong> 。</p>
<blockquote>
<p>至于为什么稀疏矩阵的定义是<strong>非零元素个数只占矩阵元素总数的25%—30%,或低于这个百分数</strong>，那是因为超过这个百分数太多三元组就不是压缩而是扩容了……</p>
</blockquote>
<h4 id="1、三元组表示法："><a href="#1、三元组表示法：" class="headerlink" title="1、三元组表示法："></a>1、三元组表示法：</h4><ul>
<li>对于稀疏矩阵的压缩存储要求在存储非零元素的同时，还必须存储该非零元素在矩阵中所处的 <strong>行号</strong> 和 <strong>列号</strong> 。</li>
<li>我们将这种存储方法叫做稀疏矩阵的 <strong>三元组表示法</strong>。 </li>
</ul>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/j.png" alt="j"></p>
<p>可以看到这时一个数组中的元素就对应了三个值，因此我们可以把它们整合一下做到结构体里面。</p>
<h4 id="2、三元组表的类型定义："><a href="#2、三元组表的类型定义：" class="headerlink" title="2、三元组表的类型定义："></a>2、三元组表的类型定义：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000  <span class="comment">/*非零元素的个数最多为1000*/</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  row,  col;  <span class="comment">/*该非零元素的行下标和列下标*/</span></span><br><span class="line">    ElementType  e； <span class="comment">/*该非零元素的值*/</span></span><br><span class="line">&#125;Triple;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    Triple  data[MAXSIZE];  <span class="comment">/* 非零元素的三元组表 */</span></span><br><span class="line">    <span class="keyword">int</span> m, n, len;  <span class="comment">/*矩阵的行数、列数和非零元素的个数*/</span></span><br><span class="line">&#125;TSMatrix；</span><br></pre></td></tr></table></figure>

<h4 id="3、稀疏矩阵的转置运算："><a href="#3、稀疏矩阵的转置运算：" class="headerlink" title="3、稀疏矩阵的转置运算："></a>3、稀疏矩阵的转置运算：</h4><p>矩阵转置：指变换元素的位置，把位于（row，col）位置上的元素换到（col ，row）位置上，也就是说，把元素的行列互换，正常矩阵算法： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> TransMatrix（ElementType source[m][n], ElementType dest[n][m]）&#123;</span><br><span class="line"><span class="comment">/*Source和dest分别为被转置的矩阵和转置后的矩阵（用二维数组表示）*/</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            dest[i][ j]=source[j][i];</span><br><span class="line">  &#125;<span class="comment">//显然，由于我们对一个 m*n 矩阵进行了逐个元素的操作，时间复杂度为 O（m*n）</span></span><br></pre></td></tr></table></figure>

<p><strong>具体算法实现：</strong></p>
<p>基于人类语言来说，我们肯定会更倾向于进行下面两个步骤快速得到结果：</p>
<ol>
<li><strong>将三元组表中所有元素进行 col 与 row 的调换。</strong></li>
<li><strong>对新得到的三元组表进行重新排序。</strong></li>
</ol>
<p>虽然步骤一较为便捷，但是问题出在步骤二上：它必然涉及大量的元素移动操作，极大地影响了算法效率。</p>
<p>所以教材中介绍的两种算法都属于一次成型：</p>
<p><strong>1、序列递增转置法：</strong></p>
<p>它是将 A 三元组表按列序依次放入 B 三元组表的，这样一来转置后得到的 B 三元组表是按照 <strong>行序排列</strong> 的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*把矩阵A转置到B所指向的矩阵中去。矩阵用三元组表表示*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TransposeTSMatrix</span><span class="params">(TSMatrix  A,  TSMatrix  * B)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span>  i , j, k ;	</span><br><span class="line">    B-&gt;m= A.n ; B-&gt;n= A.m ; B-&gt;len= A.len ;</span><br><span class="line">    <span class="keyword">if</span>(B-&gt;len&gt;<span class="number">0</span>) &#123; </span><br><span class="line">        j=<span class="number">0</span>; 	<span class="comment">/* j为三元组表B的下标 */</span></span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;A.n; k++)	<span class="comment">/* 扫描三元组表A共n次，n为A的列数 */</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;A.len; i++)  	<span class="comment">/* i为三元组表A的下标 */</span></span><br><span class="line">                <span class="keyword">if</span>(A.data[i].col==k)&#123; 	<span class="comment">/* 寻找三元组表A的列值为k的进行转置 */</span> </span><br><span class="line">                    B-&gt;data[j].row=A.data[i].col</span><br><span class="line">                    B-&gt;data[j].col=A.data[i].row; </span><br><span class="line">                    B-&gt;data[j].e=A.data[i].e; </span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="comment">/* 内循环if结束*/</span></span><br><span class="line">    &#125; <span class="comment">/* if(B-&gt;len&gt;0)结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、一次定位转置法：</strong></p>
<p>方法一中，我们为了匹配出对应位置，进行了两次循环，而这也大大增加了算法的时间复杂度。因此，为了简化算法，我们的方向就是减少循环次数。</p>
<p>这里我们想到了之前的 <strong>数组地址计算</strong> ，通过地址计算，我们就可以减少一次循环。当然，为了计算的方便，有一些量必须提前得出。</p>
<blockquote>
<p>☺<strong>设两个数组</strong><br>**num[col]**：表示矩阵 A 中第 col 列中非零元个数<br>**position[col]**：指示矩阵 A 中第 col 列第一个非零元在 B 中位置（下标值）</p>
</blockquote>
<p>再遵循如下的计算方式，得出具体位置：</p>
<blockquote>
<p>① position[1] = 1</p>
<p>② position[col] = position[col - 1] + num[col - 1]</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*基于矩阵的三元组表示，采用快速转置法，将矩阵A转置为B所指的矩阵*/</span></span><br><span class="line">FastTransposeTSMatrix (TSMatrix  A,  TSMatrix  * B) &#123; </span><br><span class="line">    <span class="keyword">int</span> col , t , p，q;  </span><br><span class="line">    <span class="keyword">int</span> num[MAXSIZE], position[MAXSIZE] ;</span><br><span class="line">    B-&gt;len= A.len ; B-&gt;n= A.m ; B-&gt;m= A.n ;</span><br><span class="line">    <span class="keyword">if</span>(B-&gt;len) &#123;</span><br><span class="line">        <span class="keyword">for</span>(col=<span class="number">0</span>;col&lt;A.n;col++)</span><br><span class="line">            num[col]=<span class="number">0</span>; 	 	<span class="comment">/*清零num数组*/</span></span><br><span class="line">        <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;A.len;t++)   </span><br><span class="line">            num[A.data[t].col]++; 	<span class="comment">/*计算三元组表A每一列的非零元素的个数*/</span></span><br><span class="line">        position[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(col=<span class="number">1</span>;col&lt;A.n;col++) 	<span class="comment">/*求col列中第一个非零元素在B.data[ ]中的正确位置*/</span></span><br><span class="line">            position[col]=position[col<span class="number">-1</span>]+num[col<span class="number">-1</span>]; </span><br><span class="line">        <span class="keyword">for</span>(p=<span class="number">0</span>;p&lt;A.len.p++) &#123;	<span class="comment">/* 从头扫描三元组表A一次 */</span></span><br><span class="line">            col=A.data[p].col;  </span><br><span class="line">            q=position[col]; 	 <span class="comment">/*col列中第一个非零元素在B.data[ ]中的正确位置*/</span></span><br><span class="line">            B-&gt;data[q].row=A.data[p].col;</span><br><span class="line">            B-&gt;data[q].col=A.data[p].row; </span><br><span class="line">            B-&gt;data[q].e=A.data[p].e</span><br><span class="line">            position[col]++; 	<span class="comment">/*col列中下一个非零元素在B.data[ ]中的正确位置，修改了position数组*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>教材上也讲了，其实这是拿空间复杂度换了时间复杂度。</p>
<h4 id="4、十字链表——稀疏矩阵的链式存储结构："><a href="#4、十字链表——稀疏矩阵的链式存储结构：" class="headerlink" title="4、十字链表——稀疏矩阵的链式存储结构："></a>4、十字链表——稀疏矩阵的链式存储结构：</h4><p>不需要怎么具体阐述，就记住是俩维度的链表，重要的是具体结构很特殊。</p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/k.png" alt="k"></p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/l.png" alt="l"></p>
<p><strong>十字链表的结构类型定义</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span>  row,  col;        <span class="comment">/* 非零元素的行和列下标 */</span></span><br><span class="line">    ElementType     value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OLNode</span>  *<span class="title">down</span>, * <span class="title">right</span>;</span>  <span class="comment">/* 非零元素所在行表列表的后继链域 */</span></span><br><span class="line">&#125;OLNode; *OLink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    OLink  * row_head,  *col_head;   <span class="comment">/* 行、列链表的头指针数组 */</span></span><br><span class="line">    <span class="keyword">int</span>  m,  n,  len;      <span class="comment">/* 稀疏矩阵的行数、列数、非零元素的个数 */</span></span><br><span class="line">&#125;CrossList; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-4、广义表"><a href="#5-4、广义表" class="headerlink" title="5.4、广义表"></a>5.4、广义表</h2><p>☺ <strong>广义表</strong> 是线性表的推广，是有限个元素的序列，其逻辑结构表示法：<br>    ♫  GL = （d1，d2，d3，…，dn）<br>☺ 广义表中的di既可以是 <strong>单个元素</strong>，还可以是一个 <strong>广义表</strong>。<br>☺ GL是广义表的名字，通常用大写字母表示。<br>☺ n是广义表的 <strong>长度</strong>。<br>☺ 若 di是一个广义表，则称di是广义表GL的子表。<br>☺ 在GL中， d1是GL的表头，其余部分组成的表（d2，d3，…，dn）称为GL的表尾。</p>
<h3 id="5-4-1、广义表的概念"><a href="#5-4-1、广义表的概念" class="headerlink" title="5.4.1、广义表的概念"></a>5.4.1、广义表的概念</h3><p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/m.png" alt="m"></p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/n.png" alt="n"></p>
<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/o.png" alt="o"></p>
<h3 id="5-4-2、广义表的两种储存结构："><a href="#5-4-2、广义表的两种储存结构：" class="headerlink" title="5.4.2、广义表的两种储存结构："></a>5.4.2、广义表的两种储存结构：</h3><p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/p.png" alt="p"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag;   <span class="comment">/*ATOM＝0，表示原子；LIST＝1，表示子表*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> &#123;</span>	</span><br><span class="line">    ElemTag   tag; 		<span class="comment">/*标志位tag用来区别原子结点和表结点*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>  &#123;</span>  </span><br><span class="line">        AtomType  atom;	<span class="comment">/*原子结点的值域atom*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span>  * <span class="title">hp</span>, *<span class="title">tp</span>;</span></span><br><span class="line">        &#125; htp; 			<span class="comment">/*表结点的指针域htp， 包括表头指针域hp和表尾指针域tp*/</span></span><br><span class="line">    &#125; atom_htp;   <span class="comment">/* atom_htp 是原子结点的值域atom和表结点的指针域htp的联合体域*/</span></span><br><span class="line">&#125; GLNode,  *GList； </span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/q.png" alt="q"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>ATOM, LIST&#125; ElemTag;   <span class="comment">/*ATOM＝0，表示原子；LIST＝1，表示子表*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span> &#123;</span>	</span><br><span class="line">    ElemTag   tag; 		<span class="comment">/*标志位tag用来区别原子结点和表结点*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>  &#123;</span>  </span><br><span class="line">        AtomType  atom;	<span class="comment">/*原子结点的值域atom*/</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span>  * <span class="title">hp</span>;</span></span><br><span class="line">    &#125; atom_htp; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span>  * <span class="title">tp</span>;</span></span><br><span class="line">&#125; GLNode,  *GList； </span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/11/ch5%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8/IMG_3103(20210511-004326).JPG" alt="IMG_3103(20210511-004326)"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>课内总结</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
        <tag>数组和广义表</tag>
      </tags>
  </entry>
  <entry>
    <title>dp子序列问题</title>
    <url>/2021/03/17/dp%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>PS：本文属于备忘笔记，今后遇到类似题目会持续更新</strong></p>
<p>​    今天在力扣上面看到一个子序列dp的问题，不得不感叹用dp数组解决的子序列问题还真是挺多，该题目属于困难分类，确实废了一番功夫。不过在练后回顾理清思路时，感觉其实也并没有那么难，只是有些套路有待总结——话不多说直接上题</p>
<blockquote>
<p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>
<p>字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
</blockquote>
<blockquote>
<p>示例 1：</p>
<p>输入：s = “rabbbit”, t = “rabbit”<br>输出：3<br>解释：<br>如下图所示, 有 3 种可以从 s 中得到 “rabbit” 的方案。<br>(上箭头符号 ^ 表示选取的字母)<br>rabbbit<br>^^^^ ^^<br>rabbbit<br>^^ ^^^^<br>rabbbit<br>^^^ ^^^<br>示例 2：</p>
<p>输入：s = “babgbag”, t = “bag”<br>输出：5<br>解释：<br>如下图所示, 有 5 种可以从 s 中得到 “bag” 的方案。<br>(上箭头符号 ^ 表示选取的字母)<br>babgbag<br>^^ ^<br>babgbag<br>^^    ^<br>babgbag<br>^    ^^<br>babgbag<br>  ^  ^^<br>babgbag<br>    ^^^</p>
<p>提示：</p>
<ul>
<li>0 &lt;= s.length, t.length &lt;= 1000</li>
<li>s 和 t 由英文字母组成</li>
</ul>
</blockquote>
<p>牙白，这么久了都没有更新了</p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题目</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>first</title>
    <url>/2021/03/09/first/</url>
    <content><![CDATA[<p><strong>老色皮</strong>博主终于搭了博客</p>
<p>因为平时都在搞黄涩所以基本不怎么更新&gt;V&lt;</p>
]]></content>
      <categories>
        <category>项目案例</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>image</title>
    <url>/2021/03/31/image/</url>
    <content><![CDATA[<p><img src="/2021/03/31/image/1.jpg" alt="1"></p>
<p>很淦，终于把图片弄好了</p>
<p>没想到错误原因竟然是路径符号’/‘和’\‘混了orz</p>
]]></content>
      <categories>
        <category>项目案例</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数II</title>
    <url>/2021/04/11/%E4%B8%91%E6%95%B0II/</url>
    <content><![CDATA[<p><img src="/2021/04/11/%E4%B8%91%E6%95%B0II/cover.JPG" alt="cover"></p>
<p><em>其实这道题本身难度并不大，但是这道题目与最小堆相关的解法上仍有很多值得学习的地方。</em></p>
<span id="more"></span>

<h2 id="一、题干："><a href="#一、题干：" class="headerlink" title="一、题干："></a>一、题干：</h2><blockquote>
<p>给你一个整数 n ，请你找出并返回第 n 个 丑数 。</p>
<p>丑数 就是只包含质因数 2、3 和/或 5 的正整数。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：n = 10<br>输出：12<br>解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p>输入：n = 1<br>输出：1<br>解释：1 通常被视为丑数。</p>
</blockquote>
<blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= n &lt;= 1690</li>
</ul>
</blockquote>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/ugly-number-ii">https://leetcode-cn.com/problems/ugly-number-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>建议先阅读丑数I的题目作为了解：<a href="https://leetcode-cn.com/problems/ugly-number/">https://leetcode-cn.com/problems/ugly-number/</a></p>
<h2 id="二、题解："><a href="#二、题解：" class="headerlink" title="二、题解："></a>二、题解：</h2><h3 id="1、动态规划："><a href="#1、动态规划：" class="headerlink" title="1、动态规划："></a>1、动态规划：</h3><p>实际上，最容易想到的解法就是动态规划，毕竟这种新数字可以用之前的数据推出摆明了就是动态规划。</p>
<p>那么我们该怎么建立状态转移方程呢?其实这个应该从丑数的性质开始探讨：</p>
<blockquote>
<p>“<strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。”</p>
</blockquote>
<p>因此我们新的数字肯定是要用之前的某数乘上2，3或5得到的，并且因为题目要求是升序排列，那么不难得出dp【i】=max{num1*2，num2*3，num3*5}这个方程。</p>
<p>那么现在新的问题又出现了：这三个数该如何确定呢？</p>
<p>这里我们采用三指针（a，b，c）的方法：初始位置都是第一个数，每一个指针只会单一地将所指向的数乘上2，3或者5。一旦找出max{dp【a】*2，dp【b】*3，dp【c】*5}，就将对应的指针后移。这里用C写一个判断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tar=min(dp[a]*<span class="number">5</span>,dp[b]*<span class="number">3</span>,dp[c]*<span class="number">2</span>);</span><br><span class="line">       <span class="keyword">if</span>(tar==dp[a]*<span class="number">5</span>) </span><br><span class="line">       a++;</span><br><span class="line">	   <span class="keyword">if</span>(tar==dp[b]*<span class="number">3</span>) </span><br><span class="line">       b++;</span><br><span class="line">       <span class="keyword">if</span>(tar==dp[c]*<span class="number">2</span>) </span><br><span class="line">       c++;</span><br><span class="line">       dp[i]=tar;</span><br></pre></td></tr></table></figure>

<p>这里注意三个指针乘2，3或5后的值都要参与判断，目的是为了将与最小值相等的所有指针都后移从而避免重复的情况。</p>
<h5 id="！：为何后移？"><a href="#！：为何后移？" class="headerlink" title="！：为何后移？"></a>！：为何后移？</h5><p><em>我们说过丑数是由之前的数乘2，3，5得到的，因此得到最小值后，该指针指向的数就已经没有再乘对应数的价值了（比如说a指针对应乘2，被选取后这个最小值就已经在dp队列里了，因此就可以丢弃了即a++），而其它的不变（因为丑数数列是定的，我们只是把他写出来，所有的丑数都会用上，所以上一次未成为最小值的数一定会在未来成为某位置的最小数）。</em></p>
<h3 id="2、最小堆："><a href="#2、最小堆：" class="headerlink" title="2、最小堆："></a>2、最小堆：</h3><p>用最小堆的优点是易于理解，仅需要用一个哈希表进行查重工作防止重复输出，剩下的就是模板化的堆运算，但是缺点也太明显了要写好多内容呜呜呜，并且时间复杂度为O(nlogn)远高于动态规划。</p>
<p>每次拿出最顶端的数，存入对应乘以2，3，5后的数（三个），以此类推。</p>
<p><strong>最小堆 构建、插入、删除的过程图解：</strong></p>
<p><a href="https://blog.csdn.net/hrn1216/article/details/51465270?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161812713416780357267485%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161812713416780357267485&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-51465270.first_rank_v2_pc_rank_v29&amp;utm_term=%E6%9C%80%E5%B0%8F%E5%A0%86">https://blog.csdn.net/hrn1216/article/details/51465270?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161812713416780357267485%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161812713416780357267485&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-51465270.first_rank_v2_pc_rank_v29&amp;utm_term=%E6%9C%80%E5%B0%8F%E5%A0%86</a></p>
<p>之后学习堆这一部分时会再详细整理一下各种理论知识与细节，数据结构的氵还是挺深的</p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>题目</tag>
        <tag>动态规划</tag>
        <tag>最小堆</tag>
      </tags>
  </entry>
  <entry>
    <title>关于前缀和与差分数组</title>
    <url>/2021/04/22/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<img src="/2021/04/22/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E5%92%8C/cover.JPG" alt="cover" style="zoom: 67%;">

<p><em>写这篇博客是因为前一天遇到了二维前缀和的题目，趁着这次机会（还没忘）赶紧梳理一下前缀和以及区分一下和它很像的差分</em></p>
<span id="more"></span>

<h3 id="一、从一维讲起的前缀和"><a href="#一、从一维讲起的前缀和" class="headerlink" title="一、从一维讲起的前缀和"></a>一、从一维讲起的前缀和</h3><p>前缀和——一听就知道是与总和密切相关的变量，那么究竟是什么原理呢？</p>
<p>对于一个数列（如1，3，5，7，9），我们在求其某一位或某几位数的总和时，一般采用累加的方式，而前缀和就是记录到每一位位置之前所以数累加的和。</p>
<p><img src="/2021/04/22/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E5%92%8C/a.bmp" alt="a"></p>
<p>这样其实会有一次复杂度为O(n)的遍历，和一般直接求和复杂度基本一致，为什么还要多此一举呢？原因在于我们一般将前缀和与动态规划及其它需要频繁调用数据的算法相结合，这些情况下前缀和只用遍历一次，复杂度远远低于一般求和。</p>
<h3 id="二、前缀和进阶——二维前缀和"><a href="#二、前缀和进阶——二维前缀和" class="headerlink" title="二、前缀和进阶——二维前缀和"></a>二、前缀和进阶——二维前缀和</h3><p>既然能够求解一维数组的区间和，那么我们推而广之，它是否也可以进行矩阵区域的求和呢？答案是肯定的</p>
<p><img src="/2021/04/22/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E5%92%8C/b.bmp" alt="b"></p>
<p>如上图，这里我们定义每个位置对应s数组储存的是其左上区域所有元素的总和，因此调用上方元素和左方元素，再加上a【i】【j】。但是注意我们的s[i-1][j]和s[i][j-1]其实有一片重合区域——s[i-1][j-1]，他被我们重复计算，因此需要减去其中一个。</p>
<p>所以至此，求区域总和慢慢变得像是一个数学几何问题了，用区域相减相加，再处理重合部分</p>
<p><img src="/2021/04/22/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%BC%80%E5%92%8C/c.bmp" alt="c"></p>
<p>这里我们求的是坐标（a，b）至（i，j）围成的红色矩形区域的总和，易得:</p>
<ol>
<li><strong>s[a][j-1]=BLUE+GREEN;</strong></li>
<li><strong>s[i-1][b]=ORANGE+GREEN;</strong></li>
<li><strong>s[a-1][b-1]=GREEN;</strong></li>
<li><strong>RED=GREEN+BLUE+ORANGE;</strong></li>
</ol>
<p>联立解得红色区域。</p>
<h3 id="三、前缀和的近亲——差分数组"><a href="#三、前缀和的近亲——差分数组" class="headerlink" title="三、前缀和的近亲——差分数组"></a>三、前缀和的近亲——差分数组</h3><p>如果弄清楚了前缀和，那么差分其实也好办了——我们说前缀和计算的是一段区域总和，而差分则是能方便我们快速地将一段区域上的元素同时加减某数。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td><strong>原始数组 a[i]</strong></td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">2</td>
<td align="center">7</td>
<td align="center">12</td>
<td align="center">6</td>
</tr>
<tr>
<td><strong>差分数组 d[i]</strong></td>
<td align="center"></td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">-3</td>
<td align="center">5</td>
<td align="center">5</td>
<td align="center">-6</td>
</tr>
</tbody></table>
<p>之前我们计算前缀和是用**s[i]=a[1]+a[2]+a[3]+…+a[i]<strong>来计算的，目的是为了使</strong>a[i]=s[i]-s[i-1]<strong>；同理，差分的公式为：</strong>d[i](差分数组)=a[i]-a[i-1]<strong>，这样就可以保证</strong>a[i]=s[1]+s[2]+s[3]+…+s[i]<strong>。注意差分数组由于公式中存在</strong>a[i-1]<strong>，所以也要在原始数组中多添加一项</strong>a[0]**防止溢出。</p>
<p>我们在用差分数组计算某一项的值时，都会从最开头累加，因此只要在差分数组上动些手脚，就能实现对区域上的元素同时加减某数。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td><strong>原始数组 a[i]</strong></td>
<td align="center">0</td>
<td align="center">3</td>
<td align="center">4+1=5</td>
<td align="center">5+1=6</td>
<td align="center">2+1=3</td>
<td align="center">7</td>
<td align="center">12</td>
<td align="center">6</td>
</tr>
<tr>
<td><strong>差分数组 d[i]</strong></td>
<td align="center"></td>
<td align="center">3</td>
<td align="center"><em><strong>1+1</strong></em></td>
<td align="center">1</td>
<td align="center">-3</td>
<td align="center"><em><strong>5-1</strong></em></td>
<td align="center">5</td>
<td align="center">-6</td>
</tr>
</tbody></table>
<p>由于是累加，那么在差分数组某一项上加减，它之后的所有项都会受到加减的buff，直到有一项主动减去来抵消这种影响。</p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>题目</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>博客更新</title>
    <url>/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/</url>
    <content><![CDATA[<p><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/cover.JPG" alt="cover"><em>这次更新了一下博客的细节功能（毕竟next有些设计用着不习惯），加上之前更新一直没写日志，就连着之前的一起写一下。</em></p>
<span id="more"></span>

<blockquote>
<ul>
<li>加入了本地搜索引擎，查找远古年代的文章更容易了</li>
<li>加入了看板娘，可以随时prprpr（少看点二刺螈嗷）</li>
<li>原来next的目录显示太蛋疼，改成了弹出式</li>
<li>之前不支持markdown图形渲染，现在好了</li>
<li>稍微修改了一下css让界面美观一些</li>
</ul>
</blockquote>
<p>正文就这？</p>
<p>我开个博客更新文档更新什么我心里肯定是有B数的</p>
<p><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/IMG_2704(20210413-120335).JPG" alt="IMG_2704(20210413-120335)"></p>
<p><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/a.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/b.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/c.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/d.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/e.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/f.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/g.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/h.PNG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/i.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/j.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/k.JPG" alt="福利"></p>
<p><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/l.JPG" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/m.JPG" alt="福利"></p>
<p><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/n.jpg" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/o.jpg" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/p.jpg" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/q.jpg" alt="福利"></p>
<p><a href="https://www.pixiv.net/artworks/91094381">#イース8 ダナ - Sunny Juice的插画 - pixiv(欸嘿~)</a></p>
<p><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/r.jpg" alt="福利"><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/s.jpg" alt="福利"></p>
<p><img src="/2021/06/09/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0-%E7%A6%8F%E5%88%A9/cc.jpg" alt="cc"></p>
<p>今天就是天王老子来了我也得冲死在这里</p>
]]></content>
      <categories>
        <category>项目案例</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>学习资料（笑）</title>
    <url>/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/cover.jpg" alt="cover"></p>
<span id="more"></span>

<p>​                         不是吧阿sir封面这样都敢点进来，我建议你去找个大夫看看xp有没有问题</p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/nz.jpg" alt="nz"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2425(20210318-103735).JPG" alt="IMG_2425(20210318-103735)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2525(20210322-203136).JPG" alt="IMG_2525(20210322-203136)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2663(20210408-162605).JPG" alt="IMG_2663(20210408-162605)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2527(20210323-110811).JPG" alt="IMG_2527(20210323-110811)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2528(20210323-110814).JPG" alt="IMG_2528(20210323-110814)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2583(20210330-080940).JPG" alt="IMG_2583(20210330-080940)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2592(20210402-162142).JPG" alt="IMG_2592(20210402-162142)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2630(20210405-123204).JPG" alt="IMG_2630(20210405-123204)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2640(20210407-103828).JPG" alt="IMG_2640(20210407-103828)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2655(20210408-110859).JPG" alt="IMG_2655(20210408-110859)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2543(20210325-131423).JPG" alt="IMG_2543(20210325-131423)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/IMG_2531(20210323-154152).JPG" alt="IMG_2531(20210323-154152)"></p>
<p><img src="/2021/04/08/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%88%E7%AC%91%EF%BC%89/hitplane.jpg" alt="hitplane"></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>学习资料</tag>
      </tags>
  </entry>
  <entry>
    <title>异或解码（氵）</title>
    <url>/2021/05/11/%E5%BC%82%E6%88%96%E8%A7%A3%E7%A0%81%EF%BC%88%E6%B0%B5%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2021/05/11/%E5%BC%82%E6%88%96%E8%A7%A3%E7%A0%81%EF%BC%88%E6%B0%B5%EF%BC%89/cover.JPG" alt="cover"><em>老久没有来氵过题解了所以今天写一下（从五一连休中缓过来了），这道异或解码的题中考察了比较重要的异或计算。</em></p>
<span id="more"></span>

<h3 id="一、题目"><a href="#一、题目" class="headerlink" title="一、题目"></a>一、题目</h3><h4 id="1734-解码异或后的排列"><a href="#1734-解码异或后的排列" class="headerlink" title="1734. 解码异或后的排列"></a><a href="https://leetcode-cn.com/problems/decode-xored-permutation/">1734. 解码异或后的排列</a></h4><p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p>
<p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded</code> ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p>
<p>给你 <code>encoded</code> 数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：encoded &#x3D; [3,1]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line">解释：如果 perm &#x3D; [1,2,3] ，那么 encoded &#x3D; [1 XOR 2,2 XOR 3] &#x3D; [3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：encoded &#x3D; [6,5,4,6]</span><br><span class="line">输出：[2,4,1,5,3]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= n &lt; 105</code></li>
<li><code>n</code> 是奇数。</li>
<li><code>encoded.length == n - 1</code></li>
</ul>
<h3 id="二、思路"><a href="#二、思路" class="headerlink" title="二、思路"></a>二、思路</h3><p>一开始其实我是想看看位运算是不是可以拿来解答，开局走的就很偏了，笑死，根本做不起。</p>
<p>点开提示上面写着“想想为什么n是奇数”，我一下就悟了</p>
<p>解题需要用到以下这些等式：</p>
<ol>
<li><strong>a^b=b^a;</strong></li>
<li><strong>if a^b=c,then a^c=b;</strong></li>
<li><strong>a^0=a;</strong></li>
</ol>
<p>其实示例一这种特殊情况（前n个整数未打乱）已经十分亲切了，我们把数字1，2，3……正好看作第一个、第二个、第三个数……，那么就可以得到一张关于perm和encoded数组关系的表：</p>
<table>
<thead>
<tr>
<th>encoded  index</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">……</th>
<th align="center">i</th>
</tr>
</thead>
<tbody><tr>
<td><strong>对perm的关系</strong></td>
<td align="center">perm[1]<strong>XOR</strong>perm[2]</td>
<td align="center">perm[2]<strong>XOR</strong>perm[3]</td>
<td align="center">perm[3]<strong>XOR</strong>perm[4]</td>
<td align="center">……</td>
<td align="center">perm[i]<strong>XOR</strong>perm[i+1]</td>
</tr>
</tbody></table>
<p>仔细观察发现，encoded数组中所有偶数序号对应的值为：</p>
<p>perm[2]<strong>XOR</strong>perm[3]，perm[4]<strong>XOR</strong>perm[5]，……</p>
<p>而这恰好就包含了原来perm数组中除了perm【1】以外所有的元素</p>
<p>之前做过一道弱化版的异或解码，其实这里知道perm【1】其余的就都可以推出了</p>
<p>因此<strong>encoded[2]^encoded[4]^…=perm[2]^perm[3]^perm[4]^perm[5]^…</strong></p>
<p>我们可以求出正整数1~n的异或值，有<strong>1^2^3^…^n=perm[1]^perm[2]^perm[3]^…perm[n]</strong></p>
<p>由公式**if a^b=c,then a^c=b;**得：</p>
<p><strong>perm[1]=1^2^3^…^n^perm[2]^perm[3]^…perm[n]</strong></p>
<p>后面就轻松了。</p>
<h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">decode</span><span class="params">(<span class="keyword">int</span>* encoded, <span class="keyword">int</span> encodedSize, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> con=<span class="number">0</span>,en=<span class="number">0</span>;<span class="comment">//这里等于0不影响后续异或计算：因为a^0=a;</span></span><br><span class="line">  *returnSize=encodedSize+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;encodedSize+<span class="number">2</span>;i++)&#123;</span><br><span class="line">​    con^=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;encodedSize;i+=<span class="number">2</span>)&#123;</span><br><span class="line">​    en^=encoded[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span>* perm=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(*returnSize));</span><br><span class="line">  perm[<span class="number">0</span>]=con^en;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(*returnSize);i++)&#123;</span><br><span class="line">​    perm[i]=perm[i<span class="number">-1</span>]^encoded[i<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> perm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/11/%E5%BC%82%E6%88%96%E8%A7%A3%E7%A0%81%EF%BC%88%E6%B0%B5%EF%BC%89/%E6%99%9A%E5%AE%89.JPG" alt="晚安"></p>
<p><em>有些梦，虚幻却也美好</em></p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水问题</title>
    <url>/2021/04/02/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/2021/04/02/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/cover.JPG" alt="cover"></p>
<p><em>今天遇见了一道程序员面试经典题，虽然分级算是困难但实际上较好上手，并且有许多解法都能正确解决此类问题，是很好的学习材料，特此记录。</em></p>
<span id="more"></span>

<h2 id="题干："><a href="#题干：" class="headerlink" title="题干："></a><strong>题干：</strong></h2><blockquote>
<p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p>
<p><img src="/2021/04/02/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/rainwatertrap.png" alt="rainwatertrap"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 感谢 Marcos 贡献此图。</p>
<p>示例:</p>
<p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci">https://leetcode-cn.com/problems/volume-of-histogram-lcci</a></p>
</blockquote>
<p>下面是三种不同的解法：</p>
<p>[^（朴素做法是将每个height元素都向左右两边遍历，很明显这个方案时间复杂度足足有O(n^2)，在此不作赘述）]: </p>
<h2 id="一、动态规划："><a href="#一、动态规划：" class="headerlink" title="一、动态规划："></a>一、动态规划：</h2><h2 id><a href="#" class="headerlink" title></a><img src="/2021/04/02/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/dp.png" alt="动态规划解法"></h2><p>因为实际蓄水量取决于左右两边最矮的高度，因此两边重叠得到的就是对应的蓄水量（注意单个方向遍历时都是取的遍历中遇到过的最高高度）</p>
<p>时间复杂度只有O(n)。</p>
<h2 id="二、单调栈："><a href="#二、单调栈：" class="headerlink" title="二、单调栈："></a>二、单调栈：</h2><p>其实，个人觉得用单调栈其实更好一些（问就是单调栈yyds），仅用一次遍历就可以得出答案，比上一解法三次遍历更优。</p>
<p>具体操作过程主要有3步：</p>
<blockquote>
<ol>
<li><strong>设置一个单调栈用于储存元素下标（注意是下标）</strong></li>
<li><strong>开始向右依次遍历，遇到元素入栈，如果有top元素，且top比即将入栈的元素小，则出栈并计算该元素蓄水量，直至没有更小的top或者栈空</strong></li>
<li><strong>重复2步骤直至遍历结束</strong></li>
</ol>
</blockquote>
<p>至于每次如何计算蓄水量，下面有图解：</p>
<p>（来源：力扣官方题解）</p>
<p><img src="/2021/04/02/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/f11.png" alt="f11"></p>
<p><img src="/2021/04/02/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/f12.png" alt="f12"></p>
<p><img src="/2021/04/02/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/f13.png" alt="f13"></p>
<p><img src="/2021/04/02/%E6%8E%A5%E9%9B%A8%E6%B0%B4%E9%97%AE%E9%A2%98/f14.png" alt="f14"></p>
<p>由上图可见，基本上我们计算蓄水量时有三个重要的量：即将放入的元素next，栈顶元素top，以及top之前的一个元素pre。</p>
<p>每次计算蓄水量时，其实是计算一个矩形面积——长为next-pre-1，而高则是在height[pre]和height[next]中挑一个最小的（满足“木桶效应”），与height[top]做差。最后再与之前得到的总蓄水量相加。</p>
<h2 id="三、双指针："><a href="#三、双指针：" class="headerlink" title="三、双指针："></a>三、双指针：</h2><p>这个其实是最好理解的做法，算是朴素做法的一种优化设计。</p>
<p>大致思路是利用left，right两个指针进行遍历，遇到right比left高就记录沿途蓄水量并移动left至right位置，没遇到就把沿途最高的值赋给left再次遍历，直至left到倒数第二个（此时就不可能再有后续蓄水量了）结束。</p>
<p><em><strong>愿清明安康</strong></em></p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>题目</tag>
        <tag>单调栈</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构KMP算法</title>
    <url>/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/cover.JPG" alt="cover"></p>
<p><em>温馨提示：本篇属于总结，难免有疏漏和错误，如有发现建议直接囸作者，欸嘿</em></p>
<span id="more"></span>

<hr>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/hutao.JPG" alt="hutao"></p>
<hr>
<p>课上老师提到了KMP，下来了解了一下——md感觉瞬间懵逼（这就是马鹿吗i了i了）</p>
<p>KMP简介是这样的：</p>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/a.png" alt="a"></p>
<p>其中对核心要素next数组是这么介绍的：</p>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/b.png" alt="b"></p>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/c.jpeg" alt="c"></p>
<p>最核心的next求法明白了，基本上KMP就没问题了。但是不幸的是，这玩意儿特别绕……</p>
<h3 id="最长相等前后缀："><a href="#最长相等前后缀：" class="headerlink" title="最长相等前后缀："></a><strong>最长相等前后缀：</strong></h3><p>我们先看一下一个例子：<strong>abbcbabcc</strong></p>
<p>这里对于他每一位字符而言，都会有一个对应的<strong>最长</strong>相等前后缀，针对倒数第二个c而言，我们可以画个图：<img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/long.png" alt="long"></p>
<p>红框对应的就是一对最长相等前后缀，注意这里的“对称”并非是镜像的，而应该是以“a”，“a b”为整体的中心对称。</p>
<p>现在再回到next求法上面。</p>
<h3 id="关于NEXT："><a href="#关于NEXT：" class="headerlink" title="关于NEXT："></a>关于NEXT：</h3><p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/next.png" alt="next"></p>
<p>这里的方程其实给人一种动态规划的状态转移方程的感觉（然而这个其实不是），但是问了一些ACM大手子，他们认为确实用了动态规划的一些思想但是缺少最优子结构什么的……</p>
<blockquote>
<p>我觉得KMP有dp的思想，但不能算dp，你可以认为它做了两个事情：构造状态转移关系和根据关系转移，但是并没有明确的最优子结构和转移方程，硬要说的话，更接近记忆化搜索或者自动机</p>
</blockquote>
<p>上面定义中，next[0]=-1是为了算法方便做的改动（实际j=0和j=-1都对应0）</p>
<p>在这个过程中，最重要的其实就是确定当前的Max{k}，我们先看看GetNext代码：</p>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/GetNext.png" alt="GetNext"></p>
<p>next[j]=k是记录当前最长相等前后缀长度，但是k=next[k]呢？这里就是理解这个函数的最大障碍，要弄清楚这个原理，我们再看看字符串中的对称：<br>$$<br>比如“abcdeabcdef”这个字符串<br>$$<br>字符串中“e”元素对应<strong>最长相等前后缀</strong>其实就是“abcde”，我们可以这么划分一下：</p>
<p><strong>【abcde】【abcde】f</strong></p>
<p>此时元素“f”出现了不匹配，那么我们就要找到一个新的<strong>最长相等前后缀</strong>，而这个新的最长相等前后缀肯定是小于“abcde”且除新的“f”元素以外都包含于“abcde”的，此时由于<strong>【abcde】【abcde】f</strong>中两个“abcdef”彼此对称，我们就可以把k回溯至开头的“abcde”后进行判定。</p>
<p>如此反复调用之前记录过的next[k]数据，即可求得新的最长相等前后缀。这里有两篇教程：</p>
<p><a href="https://blog.csdn.net/weixin_34080571/article/details/93982239?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=KMPnext&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-93982239.first_rank_v2_pc_rank_v29">https://blog.csdn.net/weixin_34080571/article/details/93982239?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=KMPnext&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-93982239.first_rank_v2_pc_rank_v29</a></p>
<p><a href="https://www.cnblogs.com/dusf/p/kmp.html">https://www.cnblogs.com/dusf/p/kmp.html</a></p>
<h3 id="BMP的优化："><a href="#BMP的优化：" class="headerlink" title="BMP的优化："></a>BMP的优化：</h3><p>实际上，现在我们一般用的BMP算法与上面我们推导出来的还有一些细微的不同——BMP还可以进一步优化，省去一些不必要的过程。</p>
<p>这里我们看一下目标串与模板串进行比对的函数：</p>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/betterKMP.png" alt="betterKMP"></p>
<p>其实我们的优化就是利用中间标红的<em><strong>“j=next[j]”</strong></em>，对GetNext函数进行优化</p>
<p>在比对过程中，可能会出现这样的状况：</p>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/search.jpg" alt="search"></p>
<p>可以看到其实“d”在与“c”判断后，接下来几个连续与“a”的判断是多余的，因此要更改判断方式使相同的字符不会被重复选取。</p>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/betterNext.png" alt="GetNext"></p>
<p>上图红色部分的意思是如果有t[j]==t[k]了，那么就说明KMP函数中调用next[j]肯定会出现重复，于是我们就直接跳过他调用next[k]（若再出现一致则重复递归）。</p>
<blockquote>
<p>附上详细讲解：</p>
<p><a href="https://zhuanlan.zhihu.com/p/105629613">https://zhuanlan.zhihu.com/p/105629613</a></p>
</blockquote>
<p>KMP算法大致就是这样运行的，建议再做两道题巩固一下o(*￣▽￣*)o~</p>
<hr>
<p>好了，话也说完了，那差不多就该</p>
<p><img src="/2021/04/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84KMP%E7%AE%97%E6%B3%95/IMG_2662.JPG" alt="IMG_2662"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>最大数</title>
    <url>/2021/04/12/%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    <content><![CDATA[<p><img src="/2021/04/12/%E6%9C%80%E5%A4%A7%E6%95%B0/cover.JPG" alt="cover"></p>
<p><em>主要是复习了sprintf函数，快速排序的灵活运用。</em></p>
<span id="more"></span>

<h2 id="一、题干："><a href="#一、题干：" class="headerlink" title="一、题干："></a>一、题干：</h2><blockquote>
<p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：nums = [10,2]<br>输出：”210”</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p>输入：nums = [3,30,34,5,9]<br>输出：”9534330”</p>
</blockquote>
<blockquote>
<p>示例 3：</p>
<p>输入：nums = [1]<br>输出：”1”</p>
</blockquote>
<blockquote>
<p>示例 4：</p>
<p>输入：nums = [10]<br>输出：”10”</p>
</blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= nums.length &lt;= 100</li>
<li>0 &lt;= nums[i] &lt;= 109</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/largest-number">https://leetcode-cn.com/problems/largest-number</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="二、解答："><a href="#二、解答：" class="headerlink" title="二、解答："></a>二、解答：</h2><p>题目难点在于解决先后排序问题：即在新的大小定义下调整顺序，用qsort函数加自定义比较函数cmp可以解决。</p>
<p>如何比较谁应该前置？我们可以先将相邻两个数链接组合，比较两种序列大小（比如12和3就应该比较123和312），选取较大数并将顺序重排。对整个数列操作后得到最大数列，再利用sprintf插入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> p=<span class="number">10</span>,q=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p&lt;=*a)</span><br><span class="line"></span><br><span class="line">  p*=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(q&lt;=*b)</span><br><span class="line"></span><br><span class="line">  q*=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (*b)*p+(*a)-((*a)*q+(*b));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= numsSize; i++)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(i==numsSize)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* ch=(<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">  qsort(nums, numsSize, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), cmp);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *p = ch;<span class="comment">//这里再次声明了一个字符指针p，是为了追踪每次sprintf后末尾的位置。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">sprintf</span>(p, <span class="string">&quot;%d&quot;</span>, nums[i]);</span><br><span class="line"></span><br><span class="line">​    p += <span class="built_in">strlen</span>(p);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、关于函数sprintf："><a href="#三、关于函数sprintf：" class="headerlink" title="三、关于函数sprintf："></a>三、关于函数sprintf：</h2><p>这个函数在C语言库的&lt;stdio.h&gt;中就有，以下是sprintf函数的声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>str</strong>–即是我们要写入的对象，指向一个字符数组</p>
<p><strong>format</strong>–是一个字符串，包含了要被写入到字符串 str 的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</p>
<p><strong>附加参数</strong> – 根据不同的 format 字符串，函数可能需要一系列的附加参数，每个参数包含了一个要被插入的值，替换了 format 参数中指定的每个 % 标签。参数的个数应与 % 标签的个数相同。</p>
<p>如果成功，则会返回写入字符长度（不包含’\0’），失败返回一个负数。</p>
<p><em>详细说明链接：</em></p>
<p><em><a href="https://www.runoob.com/cprogramming/c-function-sprintf.html">https://www.runoob.com/cprogramming/c-function-sprintf.html</a></em></p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>题目</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2021/04/04/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><em>这一类最长公共子序列问题属于二维数组动态规划的典型题目，非常经典所以做一下笔记。</em></p>
<p><strong>首先是题干部分：</strong></p>
<blockquote>
<p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>
<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>
<blockquote>
<p>示例 1：</p>
<p>输入：text1 = “abcde”, text2 = “ace”<br>输出：3<br>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p>输入：text1 = “abc”, text2 = “abc”<br>输出：3<br>解释：最长公共子序列是 “abc” ，它的长度为 3 。</p>
</blockquote>
<blockquote>
<p>示例 3：</p>
<p>输入：text1 = “abc”, text2 = “def”<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0 。</p>
</blockquote>
<p>提示：</p>
<ul>
<li>1 &lt;= text1.length, text2.length &lt;= 1000</li>
<li>text1 和 text2 仅由小写英文字符组成。</li>
</ul>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-subsequence">https://leetcode-cn.com/problems/longest-common-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>看见这种子序列啊，最长什么的，条件反射就会想到动态规划上，进而转到研究状态转化与条件。</p>
<p>这里我们很清晰地认识到任一个字母最长的子序列长度取决于他之前字母的最长子序列。很显然，两组字符串做动态规划，一维数组基本不太可能满足需求了，这个时候就需要用上二维数组。</p>
<p><img src="/2021/04/04/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/table.png" alt="table"></p>
<p>这里解释一下为什么表格第一行与第一列都要用0填满了——实际上这是防止边际判断和出界的一种方式（说白了就是懒，不这么搞也行就是麻烦点）。</p>
<p>表格的使用其实很简单：每次拿单行与不同列比较，遇到相同字母就将【当前位置的数】=【左上单元格的数】+1，否则就【当前位置的数】=MAX（【左边单元格的数】，【上边单元格的数】）。然后最后一行最后一列的元素就是答案啦。</p>
<p>不过这样的使用其实是有重要的含义的，比如【左上单元格的数】其实就是到当前列对应字母上一个字母时最长公共子序列长度，因此在当前已确定字母相同时，+1就相当于更新了当前最长公共子序列长度。</p>
<p>再说MAX（【左边单元格的数】，【上边单元格的数】）的含义，这其实就是一个状态转移方程的一部分（上面那个也是，欸嘿），优先选取最长的可能（与背包问题类似，都是动态规划）。</p>
<p><strong>代码如下：</strong></p>
<p>\</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ( ((a)&gt;(b)) ? (a):(b) )</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="keyword">char</span>* text1, <span class="keyword">char</span>* text2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>** table=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*)*(<span class="built_in">strlen</span>(text1)+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(text1)+<span class="number">1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">​    table[i]=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(<span class="built_in">strlen</span>(text2)+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">​    table[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(text2)+<span class="number">1</span>;i++)</span><br><span class="line"></span><br><span class="line">  table[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="built_in">strlen</span>(text1)+<span class="number">1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="built_in">strlen</span>(text2)+<span class="number">1</span>;j++)&#123;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line">​      table[i][j]=table[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">​      <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">​      table[i][j]=max(table[i<span class="number">-1</span>][j],table[i][j<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> table[<span class="built_in">strlen</span>(text1)][<span class="built_in">strlen</span>(text2)];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>主要还是要多多锻炼，动态规划有时候感觉是真的阴间OMO</p>
<p><strong>最后放一张女儿在这里o(*≧▽≦)ツ┏━┓：</strong></p>
<p><img src="/2021/04/04/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/KLEE.png" alt="KLEE"></p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题目</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>森林中的兔子</title>
    <url>/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/</url>
    <content><![CDATA[<p><img src="/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/cover.jpg" alt="cover"></p>
<p>今天的题目是兔子，很快啊，我全都码出去了啊</p>
<p>可惜年轻人不讲武德，诶，来骗，来偷袭</p>
<span id="more"></span>

<blockquote>
<p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。</p>
<p>返回森林中兔子的最少数量。</p>
<blockquote>
<p>示例:<br>输入: answers = [1, 1, 2]<br>输出: 5<br>解释:<br>两只回答了 “1” 的兔子可能有相同的颜色，设为红色。<br>之后回答了 “2” 的兔子不会是红色，否则他们的回答会相互矛盾。<br>设回答了 “2” 的兔子为蓝色。<br>此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。<br>因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。</p>
</blockquote>
<blockquote>
<p>输入: answers = [10, 10, 10]<br>输出: 11</p>
</blockquote>
<blockquote>
<p>输入: answers = []<br>输出: 0</p>
</blockquote>
<p>说明:</p>
<ol>
<li>answers 的长度最大为1000。</li>
<li>answers[i] 是在 [0, 999] 范围内的整数。</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/rabbits-in-forest">https://leetcode-cn.com/problems/rabbits-in-forest</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<p>首先看到这个题目我们就想到——</p>
<p><strong>这个：</strong></p>
<p><img src="/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/rabbit.jpeg" alt="rabbit"></p>
<p><strong>这个：</strong></p>
<p><img src="/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/tutu.jpeg" alt="tutu"></p>
<p><img src="/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/IMG_2631.PNG" alt="IMG_2631"></p>
<p><strong>还有这个(o′┏▽┓｀o) ：</strong></p>
<p><img src="/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/tu.jpg" alt="tu"></p>
<p><img src="/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/mai.png" alt="mai"></p>
<p><img src="/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/mai2.png" alt="mai2"></p>
<p>（欸嘿嘿嘿嘿，吸溜，欸嘿嘿……）</p>
<p><img src="/2021/04/04/%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/GKD.jpg" alt="GKD"></p>
<h4 id="咳咳，不闹了正经点了"><a href="#咳咳，不闹了正经点了" class="headerlink" title="咳咳，不闹了正经点了"></a><em>咳咳，不闹了正经点了</em></h4><p>这道题其实就是灵活利用哈希表，最重要的是如何理解题目：每个兔子都会说出和他相同颜色剩余兔子的数目n——所以这种这种颜色兔子应该有n+1只，因此利用哈希表对对应数量的单元格下储存即可，同时用一个变量来存放总数量。</p>
<p>那么此时还有一个问题——即若对应数目与进行数量描述的兔子相冲突该怎么办（e.g:比如[0,0,0]这种情况，这三只兔子虽然对应剩余同颜色兔子数量描述相同，却绝对不可能是一种颜色的兔子），这个时候就需要一次清零操作了——可以看作当某种颜色装满兔子后，清零变为另一种颜色，此时再次填入，再一次计算数目。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRabbits</span><span class="params">(<span class="keyword">int</span>* answers, <span class="keyword">int</span> answersSize)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">set</span>[<span class="number">1001</span>]=&#123;<span class="number">0</span>&#125;,ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;answersSize;i++)&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">if</span>(<span class="built_in">set</span>[answers[i]]==<span class="number">0</span>)<span class="comment">//只要是“0”，即是一种全新的颜色，重新计数</span></span><br><span class="line"></span><br><span class="line">​      ans+=(answers[i]+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">set</span>[answers[i]]++;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">set</span>[answers[i]]%=(answers[i]+<span class="number">1</span>);<span class="comment">//这里取模就是上文提到过的清零操作</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哎呀感觉涩图没看够啊（；´д｀）ゞ。。。</p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>题目</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>解码方法（又是动态规划）</title>
    <url>/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E5%8F%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E5%8F%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/cover.JPG" alt="cover"></p>
<p><em>其实老早就想吐槽为什么字符串的题过半都会和动态规划扯上关系○|￣|_</em></p>
<span id="more"></span>

<h3 id="一、题目："><a href="#一、题目：" class="headerlink" title="一、题目："></a>一、题目：</h3><blockquote>
<h4 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91. 解码方法"></a><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h4><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39; -&gt; 1</span><br><span class="line">&#39;B&#39; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#39;Z&#39; -&gt; 26</span><br></pre></td></tr></table></figure>

<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;226&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：没有字符映射到以 0 开头的数字。</span><br><span class="line">含有 0 的有效映射是 &#39;J&#39; -&gt; &quot;10&quot; 和 &#39;T&#39;-&gt; &quot;20&quot; 。</span><br><span class="line">由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;06&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;06&quot; 不能映射到 &quot;F&quot; ，因为字符串含有前导 0（&quot;6&quot; 和 &quot;06&quot; 在映射中并不等价）。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 只包含数字，并且可能包含前导零。</li>
</ul>
</blockquote>
<p>不能说是完全看懂吧，只能说是根本不会</p>
<img src="/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E5%8F%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/a.JPG" alt="a" style="zoom:50%;">

<h3 id="二、思路整理："><a href="#二、思路整理：" class="headerlink" title="二、思路整理："></a>二、思路整理：</h3><p>在看到题目之后，由于字符串和方案数量求解的存在，第一反应就是动态规划，毕竟字符串和数组契合度比较好，也很容易加入一个动态规划数组（想起被字符串支配的恐惧）。</p>
<p>通过观察可以发现‘A’到‘Z’分别映射了1~26的数字，最大的26只不过是一个两位数，所以只会出现两种解读方式——单位或双位。</p>
<p>那么该如何建立状态转移方程呢？我们另设一个数组用来存放当前位置对应的不同解读数量，那么在字符串中向后遍历的过程可以看作是在末尾插入新元素，此时新元素对应的动态分配数组中该填入什么呢？</p>
<p><img src="/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E5%8F%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/b.bmp" alt="b"></p>
<p>上图中我们不难看出，新插入的‘4’于之前的‘1’构成了两种不同的情况——要么‘4’解释为D的映射，要么‘14’解释为N的映射。不管哪种映射，加上它对应的前字符串（图中红框和橙框部分）后可能解释的数量都等于截止对应前字符串最后一个字符（图中红点和橙点部分）时的可能解释数量。——即有ans【i】=ans【i-1】+ans【i-2】。</p>
<p>但是对于一些特殊情况，这个方程是错误的——比如我们现在再在‘4’后方插入一个‘5’，它将无法用‘45’进行解释（超过了26这个边界）方程变成了ans【i】=ans【i-1】，而如果插入的是‘0’，运气恐怕就不会那么好了——整个字符串将不会再存在任何合理解释——即直接返回0。</p>
<p><img src="/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E5%8F%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/c.PNG" alt="亡牌飞行员"></p>
<p>好嘛……确定状态转移方程5分钟，处理边界条件2小时。</p>
<p>不过历史告诉我们一个道理——路越走越硌脚了，十有八九你走错道了，边界判断你越处理越难受，也说明多半方法出问题了。</p>
<p>还记得我们之前在<a href="https://picof.github.io/2021/04/04/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/">最长公共子序列</a>中提到过的防止边界判定的方法吗——将第一个元素置零，这个问题中同样奏效，只不过设置后要注意字符串与动态规划数组有一位的偏差。</p>
<h3 id="三、代码："><a href="#三、代码：" class="headerlink" title="三、代码："></a>三、代码：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果开头就是‘0’一定无解</span></span><br><span class="line">  <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">int</span>* ans=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(len+<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len;i++)</span><br><span class="line">  ans[i]=<span class="number">0</span>;<span class="comment">//初始化数组</span></span><br><span class="line">  ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  ans[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//将前两位置为1，方便运算</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">​    <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">​      <span class="keyword">if</span>(s[i<span class="number">-1</span>]&lt;=<span class="string">&#x27;0&#x27;</span>||s[i<span class="number">-1</span>]&gt;<span class="string">&#x27;2&#x27;</span>)<span class="comment">//既无法和前一个数组合，本身又是‘0’，一定无解了</span></span><br><span class="line">​      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">​    ans[i+<span class="number">1</span>]+=ans[i<span class="number">-1</span>];<span class="comment">//可以和前一个字符结合，但本身无法单独解释</span></span><br><span class="line">​    <span class="keyword">continue</span>;</span><br><span class="line">​    &#125; </span><br><span class="line">​    ans[i+<span class="number">1</span>]+=ans[i];</span><br><span class="line">​    <span class="keyword">if</span>((s[i<span class="number">-1</span>]&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i<span class="number">-1</span>]&lt;<span class="string">&#x27;2&#x27;</span>)||(s[i<span class="number">-1</span>]==<span class="string">&#x27;2&#x27;</span>&amp;&amp;s[i]&lt;<span class="string">&#x27;7&#x27;</span>))&#123;</span><br><span class="line">    <span class="comment">//判断是否满足能和前一个字符结合的条件</span></span><br><span class="line">​      ans[i+<span class="number">1</span>]+=ans[i<span class="number">-1</span>];</span><br><span class="line">​    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、涩图："><a href="#四、涩图：" class="headerlink" title="四、涩图："></a>四、涩图：</h3><p><em>（直接点过来的面壁思过去(╬▔皿▔)凸）</em></p>
<p><strong>每天的题解可以不写，但是涩图一定要放出来ψ(｀∇´)ψ！！！</strong></p>
<p><img src="/2021/04/21/%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%EF%BC%88%E5%8F%88%E6%98%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/setu.PNG" alt="setu"></p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>题目</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>误上贼船学习C++面对对象</title>
    <url>/2021/04/06/%E8%AF%AF%E4%B8%8A%E8%B4%BC%E8%88%B9%E5%AD%A6%E4%B9%A0C-%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>C++</tag>
        <tag>面对对象</tag>
      </tags>
  </entry>
  <entry>
    <title>逆波兰（转载）</title>
    <url>/2021/03/16/%E9%80%86%E6%B3%A2%E5%85%B0/</url>
    <content><![CDATA[<p>输入有两行,第一行为逆波兰式的结果,第二行为输入表达式的正确计算结果。逆波兰式中相邻的数字或运算符之间不用输出空格</p>
<p>保证表达式计算的合理性,不需判断除零等情况</p>
<p>表达式的计算遵循同级运算从左向右,先乘除后加减</p>
<p>样例输入:</p>
<p>2+1*3+4</p>
<p>样例输出:</p>
<p>213*+4+</p>
<p>9</p>
<p>解题思路:</p>
<p>首先定义两个栈,一个临时存储运算符S1,另一个作为输入逆波兰式S2的存放栈</p>
<p>在S1中先放入一个‘#’运算符调整为最低,方便运算符的比较</p>
<p>然后开始从表达式中取值</p>
<p>(1)若取出的是表达式,直接将其放置到S2存放栈中</p>
<p>(2)若取出的运算符,则将该元素与S1栈顶元素进行比较,如果该运算符优先级大于(小于或者等于都不行)S1栈顶运算符优先级,则将该运算符进S1栈,否则,将S1栈栈的栈顶运算符弹出,送入S2栈,之后再和S1现在的栈顶比较,直到运算符优先级大于栈顶为止后，将该运算符送入S1中</p>
<p>(3)重复上述1-2步,直到所有输入字符都处理完毕</p>
<p>(4)将S1中的所有符号除‘#’以外都push到S2中</p>
<p>这样我们就得到了一个逆波兰序列</p>
<p>计算结果:</p>
<p>将逆波兰式依次堆入一个栈中,如果堆入的是一个运算符,取出栈里的头两个操作数(必为数字),将其执行运算符所代表的操作后</p>
<p>(一般是 下 运算符 上),将结果放回栈中,最后剩下的栈顶就是结果</p>
<p>代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">am&gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">precede</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (a)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comparePrecde</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span> </span>&#123;  <span class="comment">//前表达式中的元素 后栈中的元素</span></span><br><span class="line">	<span class="keyword">int</span> pre_a = precede(a);</span><br><span class="line">	<span class="keyword">int</span> pre_b = precede(b);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (pre_a &gt; pre_b) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; numStack;  <span class="comment">//用来存储数字</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; exprStack;  <span class="comment">//用来存储表达式</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; tempStack;  <span class="comment">//暂时存储</span></span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">float</span>&gt; resStack;  <span class="comment">//用来存储计算结果</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; opVec;   <span class="comment">//正序输出</span></span><br><span class="line">	exprStack.push(<span class="string">&#x27;#&#x27;</span>);   </span><br><span class="line"> </span><br><span class="line">	<span class="built_in">string</span> buffer;   <span class="comment">//用来读取中缀表达式</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; buffer;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.size(); ++i) &#123;   <span class="comment">//数字和运算符分离</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(buffer[i])) &#123;</span><br><span class="line">			numStack.push(buffer[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!comparePrecde(buffer[i], exprStack.top())) &#123;</span><br><span class="line">				numStack.push(exprStack.top());</span><br><span class="line">				exprStack.pop();</span><br><span class="line">			&#125;</span><br><span class="line">			exprStack.push(buffer[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (exprStack.top() != <span class="string">&#x27;#&#x27;</span>) &#123;     <span class="comment">//剩余的元素压入栈</span></span><br><span class="line">		numStack.push(exprStack.top());</span><br><span class="line">		exprStack.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (!numStack.empty()) &#123;</span><br><span class="line">		opVec.push_back(numStack.top());</span><br><span class="line">		tempStack.push(numStack.top());</span><br><span class="line">		numStack.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	reverse(opVec.begin(), opVec.end());  <span class="comment">//输出逆波兰式列</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : opVec) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; x;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//计算结果</span></span><br><span class="line">	<span class="keyword">while</span> (!tempStack.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(tempStack.top())) &#123;</span><br><span class="line">			resStack.push((<span class="keyword">float</span>)(tempStack.top() - <span class="string">&#x27;0&#x27;</span>));  <span class="comment">//char to int</span></span><br><span class="line">			tempStack.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">char</span> expr = tempStack.top();</span><br><span class="line">			tempStack.pop();</span><br><span class="line">			<span class="keyword">float</span> a = resStack.top();</span><br><span class="line">			resStack.pop();</span><br><span class="line">			<span class="keyword">float</span> b = resStack.top();</span><br><span class="line">			resStack.pop();</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">switch</span> (expr)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span><span class="number">&#x27;</span>+<span class="string">&#x27;:</span></span><br><span class="line">				resStack.push(b + a);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span><span class="number">&#x27;</span>-<span class="string">&#x27;:</span></span><br><span class="line">				resStack.push(b - a);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span><span class="number">&#x27;</span>*<span class="string">&#x27;:</span></span><br><span class="line">				resStack.push(b * a);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span><span class="number">&#x27;</span>/<span class="string">&#x27;:</span></span><br><span class="line">				resStack.push(b / a);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; resStack.top() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//输出结果</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>————————————————<br>版权声明：本文为CSDN博主「alex1997222」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/alex1997222/article/details/82764166">https://blog.csdn.net/alex1997222/article/details/82764166</a></p>
]]></content>
      <categories>
        <category>程序算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题目</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++项目总结</title>
    <url>/2021/05/27/C-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<img src="/2021/05/27/C-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/IMG_2999(20210503-020300).JPG" alt="IMG_2999(20210503-020300)" style="zoom: 33%;">

<p><em>说起来是真的惨，经过近两周的抱佛脚式学习，已经被这个面对对象 C++ 折磨的菠萝菠萝大OMO，然而实际学会的东西真就屈指可数，甚至可以说是完全零提升，下次选课一定要慎重了。</em></p>
<span id="more"></span>

<h3 id="一、类，对象与继承："><a href="#一、类，对象与继承：" class="headerlink" title="一、类，对象与继承："></a>一、类，对象与继承：</h3><h4 id="1、类"><a href="#1、类" class="headerlink" title="1、类"></a>1、类</h4><p>C++相比C语言，加入了面对对象编程，而类则是其核心特性，非常重要。</p>
<p>类中存在的数据和方法都称为类的成员。</p>
<p>那么类应该如何定义呢：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Access specifiers:<span class="comment">//访问修饰符：一般有 private/public/protected</span></span><br><span class="line">    	Date members/variables;<span class="comment">//变量</span></span><br><span class="line">    	<span class="function">Member <span class="title">functions</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//方法</span></span><br><span class="line">&#125;；<span class="comment">//分号结束对一个类的定义</span></span><br></pre></td></tr></table></figure>

<p>这其实就是把所有相关的变量和方法都装到了一个盒子里——称之为数据封装</p>
<p>感觉有点像一个大结构体（多了函数和一些杂七杂八的东西）</p>
<p>内部任何变量或方法可以直接调用，外部就需要根据情况用 <strong>“ . “</strong> 和 <strong>“-&gt;”</strong> 来进行调用。</p>
<blockquote>
<p>补充：这里还有一个特殊的调用工具—— <strong>“ this ” 指针</strong></p>
<p>它的作用就是返回当前这个对象自己的指针，在函数内部可以用来指向调用对象</p>
</blockquote>
<p><strong>访问修饰符：</strong>分成了 private / public / protected 三类，每次声明写一次就够了，后面直到遇到下一个访问修饰符为止都会归为刚刚声明的属性类型。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> num;</span><br><span class="line">      <span class="keyword">int</span> species;<span class="comment">//以上两个变量均为public</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">int</span> consume;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="关于构造函数与析构函数："><a href="#关于构造函数与析构函数：" class="headerlink" title="关于构造函数与析构函数："></a><strong>关于构造函数与析构函数：</strong></h5><p>这俩家伙一个是负责在你用这个类创建新的对象的时候进行，而且 <strong>什么类型都不会返回</strong>（包括void）</p>
<p>虽然不能返回类型，但是我们是可以传入参数并进行操作的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">classname::classname(<span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">    variable=k;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;init successfully!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="comment">//然后运行时，内部的一切操作都会在新对象建立时自动运行</span></span><br></pre></td></tr></table></figure>

<p>更简便的，C++ 支持使用初始化列表来快速赋值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">classname::classname(int k,int l):variable a(k),variables b(l)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;init successfully!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而另一个，则是会在你每次删除该类对象时运行，长得和构造函数像孪生兄弟一样，只不过在他前面有一个 <strong>“ ~ ”</strong> 作为区分。同样，他也不会返回任何类型，并且也 <strong>不能带有任何参数</strong> 。析构函数有助于在跳出程序（如关闭文件、释放内存等）前释放资源。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">classname::~classname()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Object is being deleted successfully!&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以抽象理解为特殊函数吧（应该）。</p>
<blockquote>
<h5 id="补充：关于访问修饰符："><a href="#补充：关于访问修饰符：" class="headerlink" title="补充：关于访问修饰符："></a>补充：关于访问修饰符：</h5><p><strong>1、</strong>private：一般来说，类中的 <strong>默认成员属性</strong> 就是 private<em>（也就是说如果没有使用任何访问修饰符，类的成员将被假定为私有成员）</em>，它代表你不能从外部进行访问，或许可以通过类内部的函数<em>（一般将这个函数设为公共成员）</em>或友元函数调用，但是直接霸王硬上弓你想都别想。</p>
<img src="/2021/05/27/C-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/b.jpg" alt="b" style="zoom: 25%;">

<p><strong>2、</strong>public：基本与private相对的，从外部可以 <strong>直接访问</strong>。</p>
<p><strong>3、</strong>protected：一般来说跟 private 基本没什么不同，但是一旦给当前类派生一个子类，那么其子类就可以 <strong>随意调用</strong> 父类的 protected 中所有成员，而 private 就算是子类也调用不了（emmmmm，感觉就像给儿子的零花钱和老父亲的私房钱一样……）</p>
</blockquote>
<h4 id="2、对象"><a href="#2、对象" class="headerlink" title="2、对象"></a>2、对象</h4><p><del>清醒点找对象了</del></p>
<p>比如说我们定义了一个 animal 类，那么就可以用他来定义对象（效仿 int num 这种）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">animal bird;	<span class="comment">// 声明 animal，类型为 bird</span></span><br><span class="line">animal monkey;	<span class="comment">// 声明 animal，类型为 monkey</span></span><br></pre></td></tr></table></figure>

<p>我们定义出来的对象包含的数据都是以对应类为标准制作的</p>
<p>调用任何权限允许的公共数据，可以使用直接成员访问运算符 <strong>“ . ”</strong> 来访问。</p>
<p>而私有与受保护的对象就不能够由此运算符调用</p>
<h4 id="3、继承"><a href="#3、继承" class="headerlink" title="3、继承"></a>3、继承</h4><pre class="mermaid">graph TB
A("————<br>|Vehicle|<br>————<br>drive()<br>sit in()")-->B("———<br>|Plane|<br>———<br>fly()")</pre>

<p>如上图，这里我们设置了飞机和载具两个不同的类，但是飞机和载具是存在一层 <strong>包含关系</strong> 的，即载具共有的性质，飞机理应全部拥有。那么我们通过 C++ 的 <strong>继承</strong> 特性就可以将载具包含的方法原封不动的传递给飞机，而在这个关系中，我们把载具类称为 <strong>基类</strong>，而被包含的飞机则称为 <strong>派生类</strong>。</p>
<p>在程序中，格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="keyword">class</span>:</span> Access specifier（访问修饰符） base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>

<p>这里的默认修饰符依然是 <strong>private</strong>。</p>
<h5 id="关于访问权限："><a href="#关于访问权限：" class="headerlink" title="关于访问权限："></a><strong>关于访问权限：</strong></h5><p>这里可以总结一张表：</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同类</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>派生类</td>
<td>√</td>
<td>√</td>
<td>X</td>
</tr>
<tr>
<td>外部类</td>
<td>√</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ul>
<li>基类的构造函数、析构函数和拷贝构造函数。</li>
<li>基类的重载运算符。</li>
<li>基类的友元函数。</li>
</ul>
<blockquote>
<p><strong>继承中的特点</strong></p>
<p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p>
<ul>
<li>1.<strong>public 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</li>
<li>2.<strong>protected 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</li>
<li>3.<strong>private 继承：</strong>基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</li>
</ul>
<p>但无论哪种继承方式，上面两点都没有改变：</p>
<ul>
<li>1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</li>
<li>2.protected 成员可以被派生类访问。</li>
</ul>
</blockquote>
<h5 id="多继承："><a href="#多继承：" class="headerlink" title="多继承："></a>多继承：</h5><p>每个派生类一定只有一个父类吗？——当然不一定，采用多继承的方式，可以让一个派生类从多个父类那里继承特性……</p>
<img src="/2021/05/27/C-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/d.jpg" alt="d" style="zoom: 80%;">

<p>具体声明方式如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;</span>派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,……</span><br><span class="line">&#123;</span><br><span class="line"> &lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里仍然使用的是public，private，protected作为访问修饰符。</p>
<blockquote>
<p>简单说一下一个不怎么常用的继承方式：<strong>虚拟继承</strong></p>
<p>比如当 B，C 两个类都继承自 A 类时，这时再声明一个类 D 继承自 B 和 C，此时由于 B、C 中都存在从 A 处继承下来的同名变量出现了重复，我们就将 A 声明为虚拟继承。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;......&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;......&#125;;<span class="comment">//虚拟继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;.....&#125;;</span><br></pre></td></tr></table></figure>

<p>不过说实在的，尽量少用</p>
<img src="/2021/05/27/C-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/e.jpg" alt="e" style="zoom:67%;">
</blockquote>
<h3 id="二、重载："><a href="#二、重载：" class="headerlink" title="二、重载："></a>二、重载：</h3><h4 id="1、函数重载"><a href="#1、函数重载" class="headerlink" title="1、函数重载"></a>1、函数重载</h4><p>简单来说，就是重复定义了同一个名字的函数，我们可以通过修改传入参数的定义或者函数内部的定义来实现对不同数据的分类处理。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f(<span class="number">5</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f(<span class="number">5.67</span>,<span class="number">7.8</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个都是在描述同一个函数，main函数中调用时会根据选取的参数类型自动挑选合适的函数部分，最后会得到：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13.47</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是重载函数不要 <strong>仅以返回类型</strong> 或者 <strong>仅以形参名字</strong> 作为区分，编译器是分不清的，他只会报错。</p>
<p>重载函数还可以设定一些默认值，方便输入信息不全时补全</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y=<span class="number">7</span>,<span class="keyword">int</span> z=<span class="number">9</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;<span class="comment">//（正确）⭕</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x=<span class="number">7</span>,<span class="keyword">int</span> y=<span class="number">9</span>,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;<span class="comment">//（错误）❌</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意的是在声明传入参数时，<strong>先将所有没有默认值的形参写入</strong>，再考虑有默认值的形参，不然你设定默认值就毫无意义了。</p>
<h4 id="2、运算符重载"><a href="#2、运算符重载" class="headerlink" title="2、运算符重载"></a>2、运算符重载</h4><p>不光函数可以重新定义或重载，<strong>这（绝大多数内置）运算符也做得到啊！！！</strong></p>
<p>当在重载运算符时，运算符该有多少传入的参数就定义多少，比如定义一个类的加法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">double</span> length; </span><br><span class="line">    	<span class="keyword">double</span> breadth;</span><br><span class="line">    Square <span class="keyword">operator</span>+(<span class="keyword">const</span> Square&amp; s)&#123;</span><br><span class="line">        Square new_square;</span><br><span class="line">        new_square.length=<span class="keyword">this</span>-&gt;length+s.length;</span><br><span class="line">        new_square.breadth=<span class="keyword">this</span>-&gt;breadth+s.breadth;</span><br><span class="line">        <span class="keyword">return</span> new_square;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">&#125;<span class="comment">//不太规范（没有构造和析构函数什么的），懂意思就行</span></span><br></pre></td></tr></table></figure>

<p>然后直接用两个square1+square2就可以直接进行相加。当然由于this指针的缘故只用传入其中一个参数。</p>
<p><strong>关于特殊运算符的重载：</strong></p>
<p>实际上之后说到迭代器的时候还要用到，比如说++与–运算自加自减符都会随着其前置或者后置而改变自身定义，我们对这两个运算符的重载也稍有不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设我们还是取上面编写好的 SQUARE 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">double</span> length; </span><br><span class="line">    	<span class="keyword">double</span> breadth;</span><br><span class="line">    Square <span class="keyword">operator</span>++ ()&#123;</span><br><span class="line">    	length++;</span><br><span class="line">        breadth++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;<span class="comment">//前缀</span></span><br><span class="line">    Square <span class="keyword">operator</span>++ (<span class="keyword">int</span>)&#123;<span class="comment">//括号中插入了 int 来表示后缀</span></span><br><span class="line">        Square s;</span><br><span class="line">    	s.length=length++;</span><br><span class="line">        s.breadth=breadth++;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其它运算符的重载方式基本大同小异，详细了解可参考 <a href="https://www.runoob.com/cplusplus/increment-decrement-operators-overloading.html">这个网站</a></p>
<h3 id="三、简单迭代器的实现："><a href="#三、简单迭代器的实现：" class="headerlink" title="三、简单迭代器的实现："></a>三、简单迭代器的实现：</h3><h4 id="1、关于vector容器"><a href="#1、关于vector容器" class="headerlink" title="1、关于vector容器"></a>1、关于vector容器</h4><p>对每种容器来说，C++ 里其实都有配套的迭代器，只不过老师这边相当离谱的把这个 ban 了叫你自己造一个，那首先还是了解一下 C++ 自带的容器好方便我们依葫芦画瓢~</p>
<p>可以将 vector 简单理解为一个能存放任意数据类型的动态数组，容器使用一个内存分配器对象来动态地处理它的存储需求。vector 一般按照 <strong>严格的线性顺序排列</strong>，可以通过元素在序列中的位置访问对应的元素。而动态数组这一属性则赋予了它 <strong>快速访问，对元素快捷的增删改查能力</strong>。</p>
<blockquote>
<p><strong>1.构造函数</strong></p>
<ul>
<li>vector():创建一个空vector</li>
<li>vector(int nSize):创建一个vector,元素个数为nSize</li>
<li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li>
<li>vector(const vector&amp;):复制构造函数</li>
<li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li>
</ul>
<p><strong>2.增加函数</strong></p>
<ul>
<li>void push_back(const T&amp; x):向量尾部增加一个元素X</li>
<li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li>
<li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li>
<li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li>
</ul>
<p><strong>3.删除函数</strong></p>
<ul>
<li>iterator erase(iterator it):删除向量中迭代器指向元素</li>
<li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li>
<li>void pop_back():删除向量中最后一个元素</li>
<li>void clear():清空向量中所有元素</li>
</ul>
<p><strong>4.遍历函数</strong></p>
<ul>
<li>reference at(int pos):返回pos位置元素的引用</li>
<li>reference front():返回首元素的引用</li>
<li>reference back():返回尾元素的引用</li>
<li>iterator begin():返回向量头指针，指向第一个元素</li>
<li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li>
<li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li>
<li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li>
</ul>
<p><strong>5.判断函数</strong></p>
<ul>
<li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li>
</ul>
<p><strong>6.大小函数</strong></p>
<ul>
<li>int size() const:返回向量中元素的个数</li>
<li>int capacity() const:返回当前向量所能容纳的最大元素值</li>
<li>int max_size() const:返回最大可允许的vector元素数量值</li>
</ul>
<p><strong>7.其他函数</strong></p>
<ul>
<li>void swap(vector&amp;):交换两个同类型向量的数据</li>
<li>void assign(int n,const T&amp; x):设置向量中前n个元素的值为x</li>
<li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li>
</ul>
</blockquote>
<p>vector 容器包含在 <strong>&lt;vector&gt;</strong> 中，所以需要 <strong>#include &lt;vector&gt;</strong> 导入。</p>
<p>常见使用语法很简单：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>/<span class="keyword">double</span>/<span class="keyword">char</span>/...&gt; someone1; <span class="comment">//这样我们就定义了一个容器</span></span><br><span class="line">    <span class="comment">//当然，我们也可以对这个容器做一些更具体的设置，比如：</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">someone2</span><span class="params">(<span class="number">5</span>)</span></span>;  	<span class="comment">//初始化了5个默认值为0的元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">someone3</span><span class="params">(<span class="number">5</span>,<span class="number">1</span>)</span></span>;	<span class="comment">//初始化了5个值为1的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; someone4&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; someone5&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;	<span class="comment">//直接赋值（一维/二维）</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">someone6</span><span class="params">(someone2)</span></span>;		<span class="comment">//同类型的vector可以互相初始化</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">someone7</span><span class="params">(a, a+<span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2、迭代器工作原理及作用"><a href="#2、迭代器工作原理及作用" class="headerlink" title="2、迭代器工作原理及作用"></a>2、迭代器工作原理及作用</h4><p>实际上我们从 vector 容器的定义中就可以知道：它主要依赖于指针的调用来操作元素，因此，我们在编写迭代器的时候就一定要将指针作为核心来考虑。</p>
<p>一般简单的迭代器至少要有 <strong>初始化</strong>、<strong>返回自身指针</strong>、<strong>指针算数</strong> 这三种操作。初始化可以使用函数重载，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List_iterator</span> &#123;</span></span><br><span class="line">	Node* data;</span><br><span class="line">	List_iterator() &#123;</span><br><span class="line">		data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;<span class="comment">//不附带传入参数的初始化默认为空指针</span></span><br><span class="line">	List_iterator(People* other) &#123;</span><br><span class="line">		data = other;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//这样实现了附带传入参数的初始化</span></span><br></pre></td></tr></table></figure>

<p>而返回自身指针、指针算数这类属于带有运算符的特殊操作，则需要用到运算符重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">List_iterator&amp; <span class="keyword">operator</span> ++ () &#123; </span><br><span class="line">		data = data-&gt;next;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	List_iterator&amp; <span class="keyword">operator</span> ++ (<span class="keyword">int</span>) &#123;</span><br><span class="line">		List_iterator* pre=<span class="keyword">new</span> List_iterator;</span><br><span class="line">		pre-&gt;data= <span class="keyword">this</span>-&gt;data;</span><br><span class="line">		data = data-&gt;next;</span><br><span class="line">		<span class="keyword">return</span> *pre;</span><br><span class="line">	&#125;</span><br><span class="line">	People* <span class="keyword">operator</span> * () &#123;</span><br><span class="line">		<span class="keyword">return</span> data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> List_iterator&amp; rhs) &#123;</span><br><span class="line">		<span class="keyword">return</span> (rhs.data != data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> List_iterator&amp; rhs) &#123;</span><br><span class="line">		<span class="keyword">return</span> (rhs.data == data);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>主要注意自加自减的前后缀区分。</p>
<p><img src="/2021/05/27/C-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/a.jpg" alt="a"></p>
<h3 id="四、泛型编程初版——模板："><a href="#四、泛型编程初版——模板：" class="headerlink" title="四、泛型编程初版——模板："></a>四、泛型编程初版——模板：</h3><h4 id="1、函数模板"><a href="#1、函数模板" class="headerlink" title="1、函数模板"></a>1、函数模板</h4><p>模板是什么？</p>
<p>想象一下，如果只让我们使用函数重载，编写实现对应不同数据类型不同参数量的函数，会怎么样呢？或许一两个简单函数对你来处理绰绰有余，但要是上百个、上千个呢？你妥妥的会累死……</p>
<p>针对这种情况，<strong>泛型编程</strong> 的思想应运而生——我们不需要确切编写针对某一种数据类型的函数或行为，我们只需要给出执行方式，让编译器自己去对应正确类型，省时省力。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; （返回类型） （函数名）(参数表)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 函数的主体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> key, <span class="keyword">typename</span> target, <span class="keyword">typename</span> peo, <span class="keyword">typename</span> <span class="built_in">list</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">statistic</span><span class="params">(key info, target ch, peo l,<span class="built_in">list</span> f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	People* pre = l-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (pre)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (info.compare(pre, ch)) &#123;</span><br><span class="line">			num++;</span><br><span class="line">			f.copy_(pre);</span><br><span class="line">		&#125;</span><br><span class="line">		pre = pre-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	f.display();</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：这里的 <strong>type</strong> 是占位符类型名称，可以在类被实例化的时候进行指定。程序员可以使用一个逗号分隔的列表来定义多个泛型数据类型。</p>
</blockquote>
<h4 id="2、类模板"><a href="#2、类模板" class="headerlink" title="2、类模板"></a>2、类模板</h4><p>其实不止于对函数我们可以使用模板来“偷懒”，类同样可以通过模板来实现更高效的运行与操作。最典型的案例当属链表这种可以存储多种类型数据的结构体。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span> </span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; elems;     <span class="comment">// 元素 </span></span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;               <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;            <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;       <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">        <span class="keyword">return</span> elems.empty(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::push (T <span class="keyword">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    elems.push_back(elem);    </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Stack&lt;T&gt;::pop () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.empty()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    elems.pop_back();         </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T Stack&lt;T&gt;::top () <span class="keyword">const</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.empty()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> out_of_range(<span class="string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elems.back();      </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//而当我们调用这个模板类时，只需要标明数据类型即可：</span></span><br><span class="line">Stack&lt;<span class="keyword">int</span>/<span class="keyword">double</span>/<span class="keyword">char</span>/...&gt; new_stack;</span><br></pre></td></tr></table></figure>

<p>在外围进行成员函数的定义时注意遵守 <strong>template&lt;模板形参列表&gt; 函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}；</strong>的语法，模板形参列表一定要和最初设定时 <strong>完全一致</strong> 才行。</p>
<p>在这里请注意，类模板是不存在 <strong>实参推演</strong> 的，也就是说直接输入 <strong>Stack&lt;2&gt; new_stack;</strong> 会引起错误。</p>
<h3 id="五、Makeflie编写："><a href="#五、Makeflie编写：" class="headerlink" title="五、Makeflie编写："></a>五、Makeflie编写：</h3><h4 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h4><p>讲道理一开始小实验做到最后发现要写 Makefile 我是想骂人的，不是说这个多难学，而是大一就装了虚拟机或者使用 Linux 系统的人真的不多，况且这个老师我不信他用个 IDE 能要了他老人家的命……</p>
<img src="/2021/05/27/C-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/f.jpg" alt="f" style="zoom:67%;">

<p><strong>具体步骤：</strong></p>
<ul>
<li>Linux 下随便找个文件夹当受害者，把你的cpp文件塞进去，sln的不要。</li>
<li>建一个名字为 Makefile 的文本文件（这里新版本可以识别首字母小写的“makefile”）</li>
<li>打开它，开始进行编写（别用 vim 刨）</li>
</ul>
<h4 id="2、编写格式"><a href="#2、编写格式" class="headerlink" title="2、编写格式"></a>2、编写格式</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">例2：</span><br><span class="line"><span class="section">myprogram: myprogram.cpp support.o</span></span><br><span class="line">	g++ myprogram.cpp support.o -o myprogram</span><br><span class="line"><span class="section">support.o: support.h support.cpp</span></span><br><span class="line">	g++ support.h support.cpp -o support.o</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o myprogram</span><br><span class="line">——————————————————————————————————————————————</span><br><span class="line">例1：</span><br><span class="line"><span class="section">CPP: CPPprogram.cpp</span></span><br><span class="line">	g++ CPPprogram.cpp -o CPP</span><br><span class="line"></span><br><span class="line"><span class="section">status.o: templates.h list.h function.h People.h status.h</span></span><br><span class="line">	g++ -c templates.h list.h function.h People.h status.h CPPprogram.cpp </span><br><span class="line">	</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm CPP</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要注意几个格式规范：</p>
<ol>
<li>冒号后面有一个空格符</li>
<li>g++ 前面是一个 “tab” 键的距离</li>
</ol>
</blockquote>
<p>除了 <strong>-o</strong> 合并为可操作文件，还可以用 <strong>-c</strong> 简单组合。makefile 的编写遵守 <strong>从后往前</strong> 的规则，最先写的是最后合并的，编译从下往上进行。</p>
<blockquote>
<ul>
<li>用了 <strong>-o</strong> 就千万不能缺少 <strong>main</strong> 函数，毕竟是执行文件；</li>
</ul>
<p>所以如果你只是想把几段代码拼起来，那么建议还是用 <strong>-c</strong> 。</p>
<ul>
<li>这里的 <strong>clean</strong> 其实并不存在对应的文件，被称为 <strong>伪目标</strong>。为了避免和文件重名的这种情况，我们可以使用一个特殊的标记 <strong>“ .PHONY ”</strong> 来显示地指明一个目标是“伪目标”，向 make 说明，不管是否有这个文件，这个目标就是“伪目标”。</li>
</ul>
</blockquote>
<p><strong>rm</strong> 这个玩意用来删除文件或者目录 <strong>-i</strong> 表示删除前逐一询问确认; <strong>-f</strong> 表示即使原档案属性设为只读，亦直接删除，无需逐一确认; <strong>-r</strong> 表示将目录及以下之档案亦逐一删除。例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">rm -r [filename]</span><br></pre></td></tr></table></figure>

<p><img src="/2021/05/27/C-%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/g.gif" alt="g"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>C++</tag>
        <tag>面对对象</tag>
      </tags>
  </entry>
  <entry>
    <title>ch6树与二叉树</title>
    <url>/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/cover.JPG" alt="cover" style="zoom:80%;">

<p>来自离散数学和数据结构的合力打击，麻了。</p>
<span id="more"></span>

<h2 id="6-1-树的概念与定义"><a href="#6-1-树的概念与定义" class="headerlink" title="6.1  树的概念与定义"></a>6.1  树的概念与定义</h2><p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/a.png" alt="a"></p>
<ul>
<li><p><strong>树（Tree）：是定义在一对多关系上的层次化数据结构</strong></p>
</li>
<li><p><strong>树的定义：树是n（n≥0）个结点的有限集合T，其中：</strong></p>
<blockquote>
<ol>
<li>有且仅有一个特定的结点，称为树的根（root），它没有直接前驱，但有零个或多个直接后继。</li>
<li>当n&gt;1时，其余结点可分为m个互不相交的有限集 T1, T2,……Tm，</li>
<li>其中Ti又是一棵树，称为根root的子树（subtree）。</li>
</ol>
</blockquote>
</li>
</ul>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/b.png" alt="b"></p>
<h3 id="6-1-1、树的（逻辑）表示"><a href="#6-1-1、树的（逻辑）表示" class="headerlink" title="6.1.1、树的（逻辑）表示"></a>6.1.1、树的（逻辑）表示</h3><ul>
<li><strong>文氏图</strong></li>
</ul>
<p>每个节点都包含它所有的子孙节点，用圈框起来</p>
<ul>
<li><strong>凹入表示法</strong></li>
</ul>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/c.png" alt="c"></p>
<ul>
<li><strong>括号表示法</strong></li>
</ul>
<p>类似于我们之前描述广义表时的表达式，上面的树化为括号表达式为：<strong>A(B(E，F)，C(G(J))，D(H，I(K，L，M)))</strong></p>
<h3 id="6-1-2、树的相关术语"><a href="#6-1-2、树的相关术语" class="headerlink" title="6.1.2、树的相关术语"></a>6.1.2、树的相关术语</h3><p>这里就重点说一下几个易混易错的点：</p>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/d.png" alt="d"></p>
<blockquote>
<p><strong>这里主要注意结点的度定义问题：</strong> 是连接子树的个数，不要把头上那根算上了</p>
<p>上图应为 <strong>三叉树</strong></p>
</blockquote>
<p>☺<strong>分支结点（非终端结点）</strong>：度不为零的结点。</p>
<p>☺<strong>叶结点（终端结点）</strong>：度为零的结点。</p>
<p>☺<strong>度为 1 的结点称为单分支结点；度为 2 的结点称为双分支结点，依此类推。</strong></p>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/e.png" alt="e"></p>
<blockquote>
<p><strong>前辈</strong> ：只要层号更小，都可以称为前辈</p>
<p><strong>后辈</strong> ：只要层号更大，都可以称为后辈</p>
</blockquote>
<h3 id="6-1-3、树的同构"><a href="#6-1-3、树的同构" class="headerlink" title="6.1.3、树的同构"></a>6.1.3、树的同构</h3><p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/f.png" alt="f"></p>
<p>反正扭来扭去完全没问题，不过只要你敢伤筋动骨砍了某条连接边，就不再是同构了</p>
<h3 id="6-1-4-、有序树和无序树"><a href="#6-1-4-、有序树和无序树" class="headerlink" title="6.1.4 、有序树和无序树"></a>6.1.4 、有序树和无序树</h3><p>有序树的定义：若将树中每个结点的各子树看成是 <strong>从左到右有次序</strong> 的(即不能互换)，则称该树为 **有序树(Ordered Tree)**。<br>无序树的定义：若将树中每个结点的各子树 <strong>从左到右是没有次序</strong> 的(即可以互换)，则称该树为 <strong>无序树</strong>。</p>
<table>
<thead>
<tr>
<th>线性结构</th>
<th>树结构</th>
</tr>
</thead>
<tbody><tr>
<td>第一个数据元素 <strong>无前驱</strong></td>
<td>根结点 <strong>无双亲</strong></td>
</tr>
<tr>
<td>最后一个数据元素 <strong>无后继</strong></td>
<td>叶结点 <strong>无孩子</strong></td>
</tr>
<tr>
<td>其它数据元素 <strong>一个前驱；一个后继</strong></td>
<td>其它结点 <strong>一个双亲；多个孩子</strong></td>
</tr>
<tr>
<td>元素之间的逻辑关系 <strong>一对一</strong></td>
<td>结点之间的逻辑关系 <strong>一对多</strong></td>
</tr>
</tbody></table>
<h2 id="6-2、二叉树"><a href="#6-2、二叉树" class="headerlink" title="6.2、二叉树"></a>6.2、二叉树</h2><p>☺<strong>二叉树是一种简单而重要的树结构。</strong></p>
<p>☺<strong>适合于计算机处理，任何树都可以转换为二叉树。</strong></p>
<p>☺<strong>二叉树是重点研究对象。</strong></p>
<h3 id="6-2-1、二叉树的定义"><a href="#6-2-1、二叉树的定义" class="headerlink" title="6.2.1、二叉树的定义"></a>6.2.1、二叉树的定义</h3><ul>
<li><strong>定义：我们把满足以下两个条件的树型结构叫做二叉树（Binary Tree）：</strong><br>（1）每个结点的度都不大于2；<br>（2）每个结点的孩子结点次序不能任意颠倒。</li>
</ul>
<ul>
<li><strong>一个二叉树的每个结点可能含有0、1或2个孩子，且每个孩子有左右之分。</strong></li>
</ul>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/g.png" alt="g"></p>
<h3 id="6-2-2、二叉树的性质"><a href="#6-2-2、二叉树的性质" class="headerlink" title="6.2.2、二叉树的性质"></a>6.2.2、二叉树的性质</h3><p>证明略。</p>
<ul>
<li><strong>性质1：在二叉树的第 i 层上至多有 2i - 1个结点( i ≥1)</strong> </li>
<li><strong>性质2：深度为 k 的二叉树至多有 2k - 1 个结点（k ≥1）</strong></li>
<li><strong>性质3：对任意一棵二叉树T，若终端结点数为n0，而其度数为2的结点数为n2，则：<br>n<sub>0</sub>= n<sub>2</sub>+1</strong> </li>
</ul>
<h4 id="满二叉树与完全二叉树："><a href="#满二叉树与完全二叉树：" class="headerlink" title="满二叉树与完全二叉树："></a>满二叉树与完全二叉树：</h4><p>这俩完全两个东西，注意区分：</p>
<p><strong>满二叉树</strong>：深度为 k 且有 2k-1个结点的二叉树。在满二叉树中，每层结点都是满的，即每层结点都具有最大结点数。</p>
<blockquote>
<p><strong>满二叉树的排序方式简单粗暴，一层层从左往右数就行了</strong></p>
</blockquote>
<p><strong>完全二叉树</strong>：对一棵具有 n 个结点的二叉树 T 按层序编号，如果编号为 i（1≤ i ≤ n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同，则称 T 为完全二叉树。</p>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/h.png" alt="h"></p>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/i.png" alt="i"></p>
<ul>
<li><strong>性质4：具有n个结点的完全二叉树的深度为：</strong></li>
</ul>
<p>$$<br>\lfloor log_{2}n\rfloor +1<br>$$</p>
<ul>
<li><strong>性质5：对于具有 n 个结点的完全二叉树，如果按照从上到下和从左到右的顺序对二叉树中的所有结点从1开始顺序编号，则对于任意的序号为 i 的结点有：</strong> </li>
</ul>
<blockquote>
<p>① 若 i  = 1, 则 i 无双亲结点<br>      若 i &gt;1, 则 i 的双亲结点为 i /2 向下取整<br>② 若 2i &gt; n, 则 i 无左孩子<br>      若 2i≤n, 则 i 结点的左孩子结点为 2i<br>③ 若 2i +1 &gt; n ,则 i 无右孩子<br>      若 2i +1≤n, 则 i 的右孩子结点为 2i+1</p>
</blockquote>
<h3 id="6-2-3、二叉树的存储结构"><a href="#6-2-3、二叉树的存储结构" class="headerlink" title="6.2.3、二叉树的存储结构"></a>6.2.3、二叉树的存储结构</h3><ul>
<li><p><strong>二叉树的结构是非线性的，每一结点最多可有两个后继。</strong></p>
</li>
<li><p><strong>二叉树的存储结构有两种：</strong></p>
<h4 id="顺序存储结构："><a href="#顺序存储结构：" class="headerlink" title="顺序存储结构："></a>顺序存储结构：</h4><p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/j.png" alt="j"></p>
<p>若深度为 K ，则需要 2<sup>k</sup> - 1 个存储单元，因此很容易造成空间浪费。</p>
<h4 id="链式存储结构："><a href="#链式存储结构：" class="headerlink" title="链式存储结构："></a>链式存储结构：</h4></li>
</ul>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/k.png" alt="k"></p>
<h2 id="6-3、二叉树的遍历"><a href="#6-3、二叉树的遍历" class="headerlink" title="6.3、二叉树的遍历"></a>6.3、二叉树的遍历</h2><ul>
<li><strong>二叉树的遍历：</strong><br>指按一定规律对二叉树中的每个结点进行访问且仅访问一次。<br><sub>即：采用一定的方法得到树中所有结点的一个线性排列 </sub></li>
<li><strong>遍历是二叉树最基本的运算，是二叉树中其他运算的基础</strong></li>
</ul>
<p>我们一般把左子树、右子树、根节点分别标为 <strong>L、R、D</strong>，并且按访问他们的顺序不同将遍历方式分成 LDR、DLR 等不同的类型；其中，<strong>前序遍历、中序遍历、后序遍历</strong> 是我们现在要讨论的重点。</p>
<blockquote>
<p>Q ：这三种方式命名的原则？</p>
<p>A ：其中，前、中、后是针对根节点而言，先访问根节点就叫做先序…… L 与 R 的顺序永远是 L 在前（对这三种来说）</p>
</blockquote>
<blockquote>
<p>Q ：访问方式？</p>
<p>A ：其实它的操作有一定的 <strong>递归性</strong>，对于每个根节点而言，在进行访问时访问到了左/右子树，则对其梅开二度，进行同类型的遍历</p>
</blockquote>
<blockquote>
<p>例：<strong>先序遍历某二叉树，若二叉树为空，则空操作，否则依次执行如下操作：</strong><br>（1）访问根结点；<br>（2）按先序遍历左子树；<br>（3）按先序遍历右子树。</p>
</blockquote>
<h3 id="6-3-1、遍历算法应用"><a href="#6-3-1、遍历算法应用" class="headerlink" title="6.3.1、遍历算法应用"></a>6.3.1、遍历算法应用</h3><h4 id="二叉树中的结点"><a href="#二叉树中的结点" class="headerlink" title="二叉树中的结点"></a>二叉树中的结点</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 先序遍历输出二叉树结点, root为指向二叉树根结点的指针 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">PreOrder</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%c  &quot;</span>, root -&gt;data);		<span class="comment">/* 输出根结点 */</span></span><br><span class="line">        PreOrder(root -&gt;LChild); 	<span class="comment">/* 先序遍历左子树 */</span></span><br><span class="line">        PreOrder(root -&gt;RChild); 	<span class="comment">/* 先序遍历右子树 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>好了，其实只需要这一个就够了。只要明白了怎么利用递归的方法遍历树，那么教材中该小节部分问题无非就是加计数器或者加判断的事了，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root -&gt;LChild==<span class="literal">NULL</span> &amp;&amp; root -&gt;RChild==<span class="literal">NULL</span>)</span><br><span class="line">            LeafCount++;</span><br></pre></td></tr></table></figure>

<p>这里用左孩子右孩子都为空判断是叶节点，再用 LeafCount 计数（全局变量）。</p>
<p>还有一种算法 b，是将其作为函数返回值（内部变量），再递归返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*后续遍历：采用分治算法，如果是空树，返回0；如果只有一个结点，返回1；</span></span><br><span class="line"><span class="comment">     否则为左右子树的叶子结点数之和 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leaf_b</span><span class="params">(BiTree root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> LeafCount;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)	</span><br><span class="line">        LeafCount =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((root-&gt;LChild==<span class="literal">NULL</span>)&amp;&amp;(root-&gt;RChild==<span class="literal">NULL</span>))</span><br><span class="line">        LeafCount =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> 		<span class="comment">/* 叶子数为左右子树的叶子数目之和 */</span></span><br><span class="line">        LeafCount = leaf_b(root-&gt;LChild) + leaf_b(root-&gt;RChild); </span><br><span class="line">    <span class="keyword">return</span> LeafCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建立二叉链表方式存储的二叉树"><a href="#建立二叉链表方式存储的二叉树" class="headerlink" title="建立二叉链表方式存储的二叉树"></a>建立二叉链表方式存储的二叉树</h4><p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/l.png" alt="l"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree *bt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    ch = getchar();</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;.&#x27;</span>) *bt=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        *bt=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode)); 	<span class="comment">//生成一个新结点</span></span><br><span class="line">        (*bt)-&gt;data=ch;</span><br><span class="line">        CreateBiTree(&amp;((*bt)-&gt;LChild)); 		<span class="comment">//生成左子树</span></span><br><span class="line">        CreateBiTree(&amp;((*bt)-&gt;RChild));		<span class="comment">//生成右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求二叉树高度"><a href="#求二叉树高度" class="headerlink" title="求二叉树高度"></a>求二叉树高度</h4><p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/m.png" alt="m"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PostTreeDepth</span><span class="params">(BiTree bt)</span> </span>&#123;   <span class="comment">/* 后序遍历求二叉树的高度递归算法 */</span></span><br><span class="line">    <span class="keyword">int</span> hl,hr,max;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        hl=PostTreeDepth(bt-&gt;LChild); 	<span class="comment">/* 求左子树的深度 */</span></span><br><span class="line">        hr=PostTreeDepth(bt-&gt;RChild); 	<span class="comment">/* 求右子树的深度 */</span></span><br><span class="line">        max=hl&gt;hr?hl:hr; 				<span class="comment">/* 得到左、右子树深度较大者*/</span></span><br><span class="line">        <span class="keyword">return</span>(max+<span class="number">1</span>); 				<span class="comment">/* 返回树的深度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>(<span class="number">0</span>);                             <span class="comment">/* 如果是空树，则返回0 */</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>或者使用 <strong>全局变量</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历求二叉树bt高度的递归算法，h为bt指向结点所在层次，初值为1*/</span></span><br><span class="line"><span class="comment">/*depth为当前求得的最大层次，为全局变量，调用前初值为0 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreTreeDepth</span><span class="params">(BiTree bt, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(h&gt;depth) </span><br><span class="line">            depth = h;		<span class="comment">/*如果该结点层次值大于depth，更新depth的值*/</span></span><br><span class="line">        PreTreeDepth(bt-&gt;Lchild, h+<span class="number">1</span>);	<span class="comment">/* 遍历左子树 */</span></span><br><span class="line">        PreTreeDepth(bt-&gt;Rchild, h+<span class="number">1</span>);	<span class="comment">/* 遍历右子树 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-2、递归消除"><a href="#6-3-2、递归消除" class="headerlink" title="6.3.2、递归消除"></a>6.3.2、递归消除</h3><p>消除递归的一个办法就是用循环去替代它，但是在大量复杂的情况下，递归的问题无法直接转换成循环。所以我们这里的解决方案是用队列和栈来消除递归。</p>
<ul>
<li><strong>可以用队列消除递归。</strong></li>
<li><strong>可采用工作栈消除递归。工作栈提供一种控制结构：</strong><br>当递归算法进层时需要将信息保留；<br>当递归算法出层时需要从栈区退出信息。</li>
</ul>
<h4 id="基于队列："><a href="#基于队列：" class="headerlink" title="基于队列："></a>基于队列：</h4><p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/n.png" alt="n"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree bt)</span></span>&#123;</span><br><span class="line">    BiTree Queue[MAXNODE];	<span class="comment">/*定义队列*/</span></span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">    <span class="keyword">if</span> (bt==<span class="literal">NULL</span>) <span class="keyword">return</span>; 		<span class="comment">/*空二叉树，遍历结束*/</span></span><br><span class="line">    front=<span class="number">0</span>; rear=<span class="number">0</span>;</span><br><span class="line">    Queue[rear]=bt;			<span class="comment">/*根结点入队列*/</span></span><br><span class="line">    rear++;</span><br><span class="line">    <span class="keyword">while</span>((rear!=front)&#123; 		<span class="comment">/*队列不空，继续遍历，否则，遍历结束*/</span></span><br><span class="line">        visit(Queue[front]-&gt;data); 	<span class="comment">/*访问刚出队的元素*/</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[front]-&gt;lchild!=<span class="literal">NULL</span>) &#123;	<span class="comment">/*如果有左孩子，左孩子入队*/</span></span><br><span class="line">            Queue[rear]=Queue[front]-&gt;lchild;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>[front]-&gt;rchild!=<span class="literal">NULL</span>)&#123;	<span class="comment">/*如果有右孩子，右孩子入队*/</span></span><br><span class="line">            Queue[rear]=Queue[front]-&gt;rchild;</span><br><span class="line">            rear++;</span><br><span class="line">        &#125;</span><br><span class="line">        front++;  <span class="comment">/*出队*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于栈："><a href="#基于栈：" class="headerlink" title="基于栈："></a>基于栈：</h4><p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/o.png" alt="o"></p>
<p><strong>先序遍历非递归算法1</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder1</span><span class="params">(BiTNode *b)</span> </span>&#123;</span><br><span class="line">       BiTNode *p;</span><br><span class="line">       SqStack *st;				<span class="comment">//定义栈指针st</span></span><br><span class="line">       InitStack(st);			<span class="comment">//初始化栈st</span></span><br><span class="line">       <span class="keyword">if</span> (b!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">	Push(st，b);			<span class="comment">//根结点进栈</span></span><br><span class="line">	<span class="keyword">while</span> (!StackEmpty(st)) &#123; 	<span class="comment">//栈不为空时循环</span></span><br><span class="line">	        Pop(st，p);			<span class="comment">//退栈结点p并访问它</span></span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，p-&gt;data);</span><br><span class="line">	        <span class="keyword">if</span> (p-&gt;rchild!=<span class="literal">NULL</span>)	<span class="comment">//有右孩子时将其进栈</span></span><br><span class="line">		  Push(st，p-&gt;rchild);</span><br><span class="line">	        <span class="keyword">if</span> (p-&gt;lchild!=<span class="literal">NULL</span>)	<span class="comment">//有左孩子时将其进栈</span></span><br><span class="line">		   Push(st，p-&gt;lchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       DestroyStack(st);			<span class="comment">//销毁栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>先序遍历非递归算法2</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder2</span><span class="params">(BiTNode *b)</span></span>&#123;</span><br><span class="line">    BiTNode *p;  SqStack *st;	<span class="comment">//定义一个顺序栈指针st</span></span><br><span class="line">    InitStack(st);			<span class="comment">//初始化栈st</span></span><br><span class="line">    p=b;</span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(st) || p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="literal">NULL</span>) &#123; <span class="comment">//访问结点p及其所有左下结点并进栈</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>，p-&gt;data);	<span class="comment">//访问结点p</span></span><br><span class="line">            Push(st，p);		<span class="comment">//结点p进栈</span></span><br><span class="line">            p=p-&gt;lchild;		<span class="comment">//移动到左孩子</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下考虑栈顶结点</span></span><br><span class="line">        <span class="keyword">if</span> (!StackEmpty(st)) &#123;	<span class="comment">//若栈不空</span></span><br><span class="line">            Pop(st，p);		<span class="comment">//出栈结点p</span></span><br><span class="line">            p=p-&gt;rchild;		<span class="comment">//转向处理其右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    DestroyStack(st);		<span class="comment">//销毁栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/p.png" alt="p"></p>
<p><img src="/2021/06/20/ch6%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/q.png" alt="q"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
        <tag>课内总结</tag>
        <tag>学习</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>“Go语言圣经”学习笔记</title>
    <url>/2021/07/26/%E2%80%9CGo%E8%AF%AD%E8%A8%80%E5%9C%A3%E7%BB%8F%E2%80%9D%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="Hello，World"><a href="#Hello，World" class="headerlink" title="Hello，World"></a>Hello，World</h2><p><strong>Go语言原生支持Unicode，它可以处理全世界任何语言的文本。</strong></p>
<blockquote>
<p>每个源文件都以一条<code>package</code>声明语句开始，这个例子里就是<code>package main</code>，表示该文件属于哪个包，紧跟着一系列导入（import）的包，之后是存储在这个文件里的程序语句。</p>
<p><code>main</code>包比较特殊。它定义了一个独立可执行的程序，而不是一个库。在<code>main</code>里的<code>main</code> <em>函数</em> 也很特殊，它是整个程序执行时的入口（译注：C系语言差不多都这样）。</p>
</blockquote>
<p><strong>Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。</strong>实际上，编译器会主动把特定符号后的换行符转换为分号，因此 <strong>换行符添加的位置会影响Go代码的正确解析</strong>（译注：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字<code>break</code>、<code>continue</code>、<code>fallthrough</code>或<code>return</code>中的一个、运算符和分隔符<code>++</code>、<code>--</code>、<code>)</code>、<code>]</code>或<code>&#125;</code>中的一个）。举个例子，函数的左括号<code>&#123;</code>必须和<code>func</code>函数声明在同一行上，且位于末尾，不能独占一行，而在表达式<code>x + y</code>中，可在<code>+</code>后换行，不能在<code>+</code>前换行<em>（译注：以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误）</em>。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><h2 id="查找重复的行"><a href="#查找重复的行" class="headerlink" title="查找重复的行"></a>查找重复的行</h2><h2 id="GIF动画"><a href="#GIF动画" class="headerlink" title="GIF动画"></a>GIF动画</h2><h2 id="获取URL"><a href="#获取URL" class="headerlink" title="获取URL"></a>获取URL</h2><h2 id="并发获取多个URL"><a href="#并发获取多个URL" class="headerlink" title="并发获取多个URL"></a>并发获取多个URL</h2><h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><h2 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h2>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Go</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言入门学习</title>
    <url>/2021/07/05/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="/2021/07/05/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/cover.JPG" alt="cover"></p>
<p>这是一篇关于Go语言的学习总结，会不定期更新~</p>
<span id="more"></span>

<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p>讲道理我每次都最讨厌配环境了……出个路径问题等等岔子要折腾好久。</p>
<p>首先是在官网上下Go语言的相关文件，再打开我的电脑高级配置改环境变量和系统变量：</p>
<ul>
<li><strong>GoPath 对应的是工作区域，随便开一个地就行</strong></li>
<li><strong>GoRoot 对应下载下来的 Go 相关文件，一般来说它会自动加个 /bin</strong> </li>
</ul>
<p>打开 cmd 输一下 go version 康康版本，再输个 go env 检查一下路径。</p>
<p>我的 VSC 上的 Go 环境挂了，于是下载了 GoLand ，确实香。</p>
<h3 id="二、了解基础知识"><a href="#二、了解基础知识" class="headerlink" title="二、了解基础知识"></a>二、了解基础知识</h3><h4 id="1、包、变量和函数"><a href="#1、包、变量和函数" class="headerlink" title="1、包、变量和函数"></a>1、包、变量和函数</h4><p>就基本结构而言，由于祖师爷肯汤普森和 C 语言的加成，Go 在某些方面确实与 C 有异曲同工的地方，不过在谷狗大力推行“去C语言化”的环境下，现在的 Go 基本能自举了</p>
<p>首先我们来看一个每一个程序员入门都要写的程序：Hello World</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;hello, world\n&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 main 以及 fmt 都是程序调用的包，<strong>每个 Go 程序都是由包构成的。</strong></p>
<p>import 是用路径导入 “fmt” 这个包，按照约定，包名与导入路径的最后一个元素一致。本例中有 **fmt.Printf(“hello, world\n”) **这条代码，假如直接用 Printf 是不行的。</p>
<blockquote>
<p>这和 C family 的 <strong>#include</strong> 有些相似，可以把包理解为一个函数库</p>
</blockquote>
<p>我们还注意到，Printf 的首字母是大写的，<strong>这表明他是一个已导出名</strong>，相对的小写则是未导出名，<strong>在导入一个包时，你只能引用其中已导出的名字</strong>。任何“未导出”的名字在该包外均无法访问。</p>
<p>那么问题又来了，假使我们要一次性导入多个包，该如何做呢？</p>
<p>这种情况下采用“分组”导入形式，代码用圆括号组合了导入，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a><strong>函数</strong></h5><p>关于函数，和 C 很相似，但是在类型声明时类型在变量名 <strong>之后</strong>。同样的，函数可以接受多个或不接受参数。当连续两个或多个函数的已命名形参类型相同时，<strong>除最后一个类型以外，其它都可以省略</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;<span class="comment">//这里x省略了类型</span></span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(add(<span class="number">42</span>, <span class="number">13</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在 C 语言中，我们返回值只会存在一个，而在 Go 语言中，可以做到 <strong>多值返回</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := swap(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)<span class="comment">//这里赋值也是两个变量一起赋值</span></span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="命名返回值"><a href="#命名返回值" class="headerlink" title="命名返回值"></a><strong>命名返回值</strong></h5><p>Go 的返回值可被命名，它们会被视作定义在函数顶部的变量。</p>
<p>返回值的名称应当具有一定的意义，它可以作为文档使用。</p>
<p>没有参数的 <code>return</code> 语句返回已命名的返回值。也就是 <code>直接</code> 返回。</p>
<p>我们看下面例子中 x，y 是提前命名好的，因此在无返回值时就返回他们。</p>
<p>直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="keyword">int</span>)</span> <span class="params">(x, y <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">	y = sum - x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(split(<span class="number">17</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h5><p><code>var</code> 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后，<code>var</code> 语句可以出现在包或函数级别。</p>
<p>并且支持类型的自动推导，可以从初始值中获取类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i, j <span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c, python, java = <span class="literal">true</span>, <span class="string">&quot;omg&quot;</span>, <span class="string">&quot;no!&quot;</span></span><br><span class="line">	fmt.Println(i, j, c, python, java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且有趣的是，在没有初始值只有类型的情况下，Go 会自动将变量置空，例如上例中最后输出会是 <code>0 0 true omg no!</code> <strong>i 和 j 被自动置为 0。</strong></p>
<blockquote>
<p>没有明确初始值的变量声明会被赋予它们的 <strong>零值</strong>。</p>
<p>零值是：</p>
<ul>
<li>数值类型为 <code>0</code>，</li>
<li>布尔类型为 <code>false</code>，</li>
<li>字符串为 <code>&quot;&quot;</code>（空字符串）。</li>
</ul>
</blockquote>
<h5 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a><strong>短变量声明</strong></h5><p>在函数中，简洁赋值语句 <code>:=</code> 可在类型明确的地方代替 <code>var</code> 声明。</p>
<p>函数外的每个语句都必须以关键字开始（<code>var</code>, <code>func</code> 等等），因此 <code>:=</code> 结构不能在函数外使用。</p>
<h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a><strong>基本类型</strong></h5><p>Go 的基本类型有</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> <span class="comment">// uint8 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rune</span> <span class="comment">// int32 的别名</span></span><br><span class="line">    <span class="comment">// 表示一个 Unicode 码点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float32</span> <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">complex64</span> <span class="keyword">complex128</span> <span class="comment">//复数</span></span><br></pre></td></tr></table></figure>

<p>本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。</p>
<p><code>int</code>, <code>uint</code> 和 <code>uintptr</code> 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 <code>int</code> 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。</p>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a><strong>强制类型转换</strong></h5><p>这个东西其实和 C 一样的，<strong>int（x）</strong>这样直接转类型。然而在 C 语言中系统会默认转换成等号左边的类型，也就是隐式转换——在 Go 中是无法实现的，必须要用 <strong>显示转换</strong> ！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">float64</span> = math.Sqrt(<span class="keyword">float64</span>(x*x + y*y))</span><br><span class="line">	<span class="keyword">var</span> z <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br><span class="line">    <span class="comment">//这个例子中，假若我们把 f 的强制类型转换删去变成 var z uint = f，是会发生类型错误的</span></span><br><span class="line">	fmt.Println(x, y, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a><strong>类型推导</strong></h5><p>在声明一个变量而不指定其类型时（即使用不带类型的 <code>:=</code> 语法或 <code>var =</code> 表达式语法），变量的类型由右值推导得出。</p>
<p>当右值声明了类型时，新变量的类型与其相同：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">j := i <span class="comment">// j 也是一个 int</span></span><br></pre></td></tr></table></figure>

<p>不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 <code>int</code>, <code>float64</code> 或 <code>complex128</code> 了，这取决于常量的精度：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">42</span>           <span class="comment">// int</span></span><br><span class="line">f := <span class="number">3.142</span>        <span class="comment">// float64</span></span><br><span class="line">g := <span class="number">0.867</span> + <span class="number">0.5i</span> <span class="comment">// complex128</span></span><br></pre></td></tr></table></figure>

<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h5><p>常量的声明与变量类似，只不过是使用 <code>const</code> 关键字。</p>
<p>常量可以是字符、字符串、布尔值或数值。</p>
<p>常量不能用 <code>:=</code> 语法声明。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Pi = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> World = <span class="string">&quot;世界&quot;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello&quot;</span>, World)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Happy&quot;</span>, Pi, <span class="string">&quot;Day&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Truth = <span class="literal">true</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Go rules?&quot;</span>, Truth)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、流程控制语句：for、if、else、switch-和-defer"><a href="#2、流程控制语句：for、if、else、switch-和-defer" class="headerlink" title="2、流程控制语句：for、if、else、switch 和 defer"></a>2、流程控制语句：for、if、else、switch 和 defer</h4><h5 id="关于-for"><a href="#关于-for" class="headerlink" title="关于 for"></a>关于 for</h5><blockquote>
<p>Go 只有一种循环结构：<code>for</code> 循环。</p>
<p>基本的 <code>for</code> 循环由三部分组成，它们用分号隔开：</p>
<ul>
<li>初始化语句：在第一次迭代前执行</li>
<li>条件表达式：在每次迭代前求值</li>
<li>后置语句：在每次迭代的结尾执行</li>
</ul>
<p>初始化语句通常为一句短变量声明，该变量声明仅在 <code>for</code> 语句的作用域中可见。</p>
<p>一旦条件表达式的布尔值为 <code>false</code>，循环迭代就会终止。</p>
</blockquote>
<p>值得注意的就是 Go 中 for <strong>没有使用圆括号</strong>，而 <strong>“{ }”</strong> 是 <strong>必须</strong> 的！（没有就报错）</p>
<p>同样，for 语句可以删到只剩中间一条语句，分号无所谓，实际上去掉分号就变成了 while 语句了。</p>
<h5 id="关于-if"><a href="#关于-if" class="headerlink" title="关于 if"></a>关于 if</h5><blockquote>
<p>Go 的 <code>if</code> 语句与 <code>for</code> 循环类似，表达式外无需小括号 <code>( )</code> ，而大括号 <code>&#123; &#125;</code> 则是必须的。</p>
</blockquote>
<p>麻了，怎么在一些奇奇怪怪的方面“大道至简”……</p>
<blockquote>
<p>同 <code>for</code> 一样， <code>if</code> 语句可以在条件表达式前执行一个简单的语句。</p>
<p>该语句声明的变量作用域仅在 <code>if</code> 之内。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(</span><br><span class="line">		pow(<span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>),</span><br><span class="line">		pow(<span class="number">3</span>, <span class="number">3</span>, <span class="number">20</span>),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="if-和-else"><a href="#if-和-else" class="headerlink" title="if 和 else"></a>if 和 else</h5><p>在 <code>if</code> 的简短语句中声明的变量同样可以在任何对应的 <code>else</code> 块中使用。也就是说，局部变量的作用域会拓展至 else 语句中。不过有一个很怪的点就是 else 使用时<strong>必须和 if 结尾的 “}” 相连</strong>（毕竟 Go 判断语句结尾其中一个根据就是换行）</p>
<p>同样 else if 也完全可以使用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(z <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	z=<span class="number">1.0</span></span><br><span class="line">	<span class="keyword">var</span> k <span class="keyword">float64</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		z-=(z*z-x)/(<span class="number">2</span>*z)</span><br><span class="line">		<span class="keyword">if</span> math.Abs(k-z)&lt;<span class="number">0.0000000001</span>&#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		k=z</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">	fmt.Println(math.Sqrt(<span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个利用牛顿法结合 for 和 if 语句编写的找平方根函数。</p>
<h5 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h5><p><code>switch</code> 是编写一连串 <code>if - else</code> 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。</p>
<p>与 C 不同的是，<strong>Go 自动提供了在这些语言中每个 case 后面所需的 <code>break</code> 语句。 除非以 <code>fallthrough</code> 语句结束，否则分支会自动终止。</strong>而且 case 无需为常量，且不需要是整数。</p>
<p>switch 的 case 语句从上到下顺次执行，直到 <strong>匹配成功时停止</strong>。</p>
<blockquote>
<p>例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch i &#123;</span><br><span class="line">case 0:</span><br><span class="line">case f():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>i==0</code> 时 <code>f</code> 不会被调用。</p>
</blockquote>
<p>没有条件的 switch 同 **<code>switch true</code>**一样。</p>
<p>这种形式能将一长串 if-then-else 写得更加清晰。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := time.Now()</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">12</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good morning!&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> t.Hour() &lt; <span class="number">17</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good afternoon.&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;Good evening.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>defer 语句会将函数推迟到 <strong>外层函数返回之后</strong> 执行。</p>
<p>推迟调用的函数其参数会 <strong>立即求值</strong>，但直到外层函数返回前该函数都不会被调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;counting&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们很容易看出循环中的语句会延后到 main 函数结束，然而输出的数字却呈 9、8、7、6……的倒序排列，为什么呢？</p>
<p>这是因为推迟的函数调用会被 <strong>压入一个栈</strong> 中。当外层函数返回时，被推迟的函数会按照 <strong>后进先出</strong> 的顺序调用。</p>
<h4 id="3、更多类型：struct、slice-和映射"><a href="#3、更多类型：struct、slice-和映射" class="headerlink" title="3、更多类型：struct、slice 和映射"></a>3、更多类型：struct、slice 和映射</h4><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><p>Go 拥有指针。指针保存了值的内存地址。</p>
<p>类型 <code>*T</code> 是指向 <code>T</code> 类型值的指针。其零值为 <code>nil</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p><code>&amp;</code> 操作符会生成一个指向其操作数的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure>

<p><code>*</code> 操作符表示指针指向的底层值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(*p) <span class="comment">// 通过指针 p 读取 i</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针 p 设置 i</span></span><br></pre></td></tr></table></figure>

<p>这也就是通常所说的“间接引用”或“重定向”。</p>
<p>与 C 不同，Go <strong>没有指针运算</strong>。</p>
<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>是一组字段，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X <span class="keyword">int</span></span><br><span class="line">	Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果改为 <code>var X int</code> 就会报错，这是因为 var 是声明变量，而 struct 中是<strong>不存在变量的，只有类型</strong>。</p>
<p>与 C 类似的，使用 <code>.</code> 来访问字段。（指针也一样）</p>
<p><strong>结构体指针：</strong>如果我们有一个指向结构体的指针 <code>p</code>，那么可以通过 <code>(*p).X</code> 来访问其字段 <code>X</code>。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 <code>p.X</code> 就可以。</p>
<p><strong>结构体文法：</strong></p>
<ul>
<li>使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）</li>
<li><code>&amp;</code> 求址符可以返回一个指针</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v1 = Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;  <span class="comment">// 创建一个 Vertex 类型的结构体</span></span><br><span class="line">	v2 = Vertex&#123;X: <span class="number">1</span>&#125;  <span class="comment">// Y:0 被隐式地赋予</span></span><br><span class="line">	v3 = Vertex&#123;&#125;      <span class="comment">// X:0 Y:0</span></span><br><span class="line">	p  = &amp;Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 创建一个 *Vertex 类型的结构体（指针）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>类型 <code>[n]T</code> 表示拥有 <code>n</code> 个 <code>T</code> 类型的值的数组。</p>
<p>表达式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>会将变量 <code>a</code> 声明为拥有 10 个整数的数组。</p>
<p>数组的长度是其类型的一部分，因此数组 <strong>不能改变大小</strong>。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">string</span><span class="comment">//使用字符串数组</span></span><br><span class="line">	a[<span class="number">0</span>] = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">	a[<span class="number">1</span>] = <span class="string">&quot;World&quot;</span></span><br><span class="line">	fmt.Println(a[<span class="number">0</span>], a[<span class="number">1</span>])</span><br><span class="line">	fmt.Println(a)</span><br><span class="line"></span><br><span class="line">	primes := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">    <span class="comment">//同样，可以在声明数组的同时进行初始化</span></span><br><span class="line">	fmt.Println(primes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。</p>
<p>类型 <code>[]T</code> 表示一个元素类型为 <code>T</code> 的切片。</p>
<p>切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[low : high]</span><br></pre></td></tr></table></figure>

<p>它会选择一个半开区间，<strong>包括第一个元素，但排除最后一个元素</strong>。</p>
<p>以下表达式创建了一个切片，它包含 <code>a</code> 中下标从 1 到 3 的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a[1:4]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>切片中并 <strong>不包含任何数据</strong>，他可以理解为数组的引用，<strong>更改切片的元素会修改其底层数组中对应的元素。与它共享底层数组的切片都会观测到这些修改。</strong></p>
<p>更改切片中元素时，对应初始下标位置会随着切片位置改变而变动</p>
</blockquote>
<p><strong>切片文法：</strong>类似于 C 中的变长数组。</p>
<p>当使用 <code>[]bool&#123;true, true, false&#125;</code>  时，会自动创建一个同类型的等长数组并构建一个引用它的切片，就效果而言和变长数组差不多</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	q := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;</span><br><span class="line">	fmt.Println(q)</span><br><span class="line"></span><br><span class="line">	r := []<span class="keyword">bool</span>&#123;<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>&#125;</span><br><span class="line">	fmt.Println(r)</span><br><span class="line"></span><br><span class="line">	s := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		i <span class="keyword">int</span></span><br><span class="line">		b <span class="keyword">bool</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">3</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;<span class="number">5</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">		&#123;<span class="number">11</span>, <span class="literal">false</span>&#125;,</span><br><span class="line">		&#123;<span class="number">13</span>, <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;<span class="comment">//这一段实际上是创建了一个结构体数组</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>切片的默认行为</strong></p>
<p>在进行切片时，你可以利用它的默认行为来忽略上下界。</p>
<p>切片下界的默认值为 <code>0</code>，上界则是该切片的长度。</p>
<p>对于数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>来说，以下切片是等价的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a[<span class="number">0</span>:<span class="number">10</span>]</span><br><span class="line">a[:<span class="number">10</span>]</span><br><span class="line">a[<span class="number">0</span>:]</span><br><span class="line">a[:]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：切片可以再切成更小的切片。</p>
</blockquote>
<p><strong>切片的长度与容量：</strong>切片长度就是它 <strong>包含元素的个数</strong></p>
<p>切片的容量是从它的第一个元素开始数，到 <strong>其底层数组</strong> 元素末尾的个数。</p>
<p>可以通过 <strong>len(s)</strong> 获取长度，<strong>cap(s)</strong> 获取容量。</p>
<p><strong>nil 切片：</strong></p>
<p>切片的零值是 <code>nil</code>。</p>
<p>nil 切片的长度和容量为 0 且 <strong>没有底层数组</strong>。</p>
<p><strong>用 make 创建切片：</strong></p>
<p>切片可以用内建函数 <code>make</code> 来创建，这也是你创建动态数组的方式。</p>
<p><code>make</code> 函数会分配一个元素为零值的数组并返回一个引用了它的切片：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure>

<p>要指定它的容量，需向 <code>make</code> 传入第三个参数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line"></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:]      <span class="comment">// len(b)=4, cap(b)=4</span></span><br></pre></td></tr></table></figure>

<p>切片可包含 <strong>任何类型</strong>，甚至可以切片套娃。</p>
<p><strong>向切片追加元素:</strong></p>
<p>Go 为我们提供了一个快捷追加切片元素的方法：<strong>使用内置的 <code>append</code> 函数</strong>，其函数原型为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure>

<p>其中，第一个参数 <code>s</code> 是一个元素类型为 <code>T</code> 的切片，其余类型为 <code>T</code> 的值将会追加到该 <strong>切片的末尾</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">int</span><span class="comment">// 添加一个空切片</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">1</span>)<span class="comment">// 这个切片会按需增长</span></span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)<span class="comment">// 可以一次性添加多个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后就应该是 <code>[]</code> –&gt; <code>[0]</code> –&gt; <code>[0,1]</code> –&gt; <code>[0,1,2,3,4]</code></p>
<h5 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h5><p><code>for</code> 循环的 <code>range</code> 形式可遍历切片或映射。</p>
<p>当使用 <code>for</code> 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。</p>
<p>一般是这么用的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> (数组名)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i 对应下标，v 对应元素副本（值）</p>
<p>可以将下标或值赋予 <code>_</code> 来忽略它。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pow</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure>

<p>若你只需要索引，忽略第二个变量即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pow</span><br></pre></td></tr></table></figure>

<h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>由 <strong>键</strong> 和对应的 <strong>值</strong> 组成。相较于 C++ 以及 Java，Go 的映射使用时不需要任何的库。</p>
<p>映射将键映射到值。</p>
<p>映射的零值为 <code>nil</code> 。<code>nil</code> 映射既没有键，也不能添加键。</p>
<p>对于建立映射，Go 主要提供两种方法：</p>
<p><strong>1、内置的 make 函数：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个映射，键的类型是 string，值的类型是 int</span></span><br><span class="line">myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p><code>make</code> 函数会返回给定类型的映射，并将其初始化备用。</p>
<p><strong>2、字面量声明映射（常用）：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个映射，键和值的类型都是 string</span></span><br><span class="line"><span class="comment">// 使用两个键值对初始化映射</span></span><br><span class="line">myMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;Red&quot;</span>: <span class="string">&quot;#da1337&quot;</span>, <span class="string">&quot;Orange&quot;</span>: <span class="string">&quot;#e95a22&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于这里官方文档有个示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">map</span>[<span class="keyword">string</span>]Vertex&#123;</span><br><span class="line">	<span class="string">&quot;Bell Labs&quot;</span>: Vertex&#123;</span><br><span class="line">		<span class="number">40.68433</span>, <span class="number">-74.39967</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">&quot;Google&quot;</span>: Vertex&#123;</span><br><span class="line">		<span class="number">37.42202</span>, <span class="number">-122.08408</span>,</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<p>很怪的是 Vertex 屁股后面的大括弧里最后一个数尾巴上都带了一个 <code>,</code> </p>
<p>我把它删掉后直接报错了。。。</p>
<p>原来 Go 语言中 <strong>如果一个多行切片，数组或映射文字分行表达</strong>，那么每个元素后面都要加上一个 <code>,</code></p>
</blockquote>
<p>若顶级类型只是一个 <strong>类型名</strong>，你可以在文法的元素中 <strong>省略</strong> 它。</p>
<p>比如上例中省略 Vertex 是完全科学的。</p>
<p><strong>映射的查找与修改：</strong></p>
<p>查找方式有两种：</p>
<p><strong>1、引入代表存在性的布尔值：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">elem, ok = m[key]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果<code>elem</code> <strong>或</strong> <code>ok</code> 还未声明，你可以使用短变量声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">elem, ok := m[key]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>2、直接检测对应值是否为零值：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure>

<p>但是要注意，这种方法仅仅适用于键值对中不存在零值的情况。</p>
<p><strong>如何修改与删除？</strong></p>
<p>在映射 <code>m</code> 中插入或修改元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m[key] = elem</span><br></pre></td></tr></table></figure>

<p>获取元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">elem = m[key]</span><br></pre></td></tr></table></figure>

<p>删除元素：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, key)</span><br></pre></td></tr></table></figure>

<h6 id="练习：映射"><a href="#练习：映射" class="headerlink" title="练习：映射"></a>练习：映射</h6><p>实现 <code>WordCount</code>。它应当返回一个映射，其中包含字符串 <code>s</code> 中每个“单词”的个数。函数 <code>wc.Test</code> 会对此函数执行一系列测试用例，并输出成功还是失败。</p>
<p>你会发现 <strong>strings.Fields</strong> 很有帮助。</p>
<p>网上查了一下，这个 <strong>strings.Fields</strong> 函数是将 string 字符串中被空隔开（比如空格和制表符等）的单字拆分出来放进一个数组中，因此 <strong>它的返回值一定是一个数组</strong></p>
<p>所以再用上我们之前学过的 range 循环并让对应映射位数值 <code>++</code></p>
<h5 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h5><p>函数也是值。它们可以像其它值一样传递。</p>
<p>函数值可以用作函数的参数或返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compute</span><span class="params">(fn <span class="keyword">func</span>(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span> <span class="title">float64</span>) <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hypot := <span class="function"><span class="keyword">func</span><span class="params">(x, y <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> math.Sqrt(x*x + y*y)</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(hypot(<span class="number">5</span>, <span class="number">12</span>))<span class="comment">//ans:13</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(compute(hypot))<span class="comment">//ans:5</span></span><br><span class="line">    fmt.Println(compute(math.Pow))<span class="comment">//ans:81</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出：在函数 compute 中，fn 被赋予了函数类型，因此 compute 函数中的参数是一个调用了两个浮点数返回值也是浮点数的函数。</p>
<p><strong>函数的闭包</strong></p>
<p>简而言之，闭包函数就是一个 <strong>返回值为函数</strong> 的函数，闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，<strong>该函数被这些变量“绑定”在一起</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos, neg := adder(), adder()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(</span><br><span class="line">			pos(i),</span><br><span class="line">			neg(<span class="number">-2</span>*i),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如在上例中，出现了多个 adder 返回的闭包，如果不使用闭包，就需要很多的全局变量。而使用闭包后，每个 adder 返回的闭包都与对应的 sum 值相绑定，不会出现混淆。</p>
<h3 id="三、方法和接口"><a href="#三、方法和接口" class="headerlink" title="三、方法和接口"></a>三、方法和接口</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>不同于 C++ 以及 JAVA 这类面对对象编程语言存在类这种方便的东西，Go语言没有类。</p>
<p>不过没关系，我们仍然可以通过为 <strong>结构体类型定义方法</strong> 将函数和它对应的变量相连接。</p>
<p>我们这里会使用一个叫 <strong>接收者</strong> 的参数，它位于 <code>func</code> 关键字和方法名之间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，<code>Abs</code> 方法拥有一个名为 <code>v</code>，类型为 <code>Vertex</code> 的接收者。</p>
<blockquote>
<p><strong>注</strong>：除了有个接收者以外，<strong>方法就是函数</strong> 的一种，功能都一样</p>
</blockquote>
<p><strong>可以为非结构体类型声明方法</strong>，但是！！！接收者类型必须和方法声明在 <strong>同一个包</strong> 里面！！！</p>
<blockquote>
<p>换句话说，在其它包里的内建类型（int、float 等）是不能够直接拿来作为接收者类型的，需要再一次声明一次。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span><span class="comment">//将包内 MyFloat 将其它包的 float64 替换了，效果一样</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指针接收者：</strong>你可以为指针接收者声明方法。</p>
<p>这意味着对于某类型 <code>T</code>，接收者的类型可以用 <code>*T</code> 的文法。（此外，<code>T</code> 不能是像 <code>*int</code> 这样的指针。）</p>
<p>采用指针才能使用方法 <strong>更改指针接收者指向的值</strong>。如果不采用指针，那么方法使用的仅仅是 <strong>参数对应的副本</strong>，而不会对其值有任何影响</p>
<p><strong>选择值或指针作为接收者：</strong></p>
<blockquote>
<p>使用指针接收者的原因有二：</p>
<ul>
<li>首先，方法能够 <strong>修改</strong> 其接收者指向的值。</li>
<li>其次，这样可以 <strong>避免在每次调用方法时复制该值</strong>。若值的类型为大型结构体时，这样做会 <strong>更加高效</strong>。</li>
</ul>
</blockquote>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口是一组 <strong>仅包含方法名、参数、返回值的未具体实现的</strong> 方法的集合。</p>
<p>接口是一种 <strong>类型</strong></p>
<p>在 C++ 等面对对象编程中，很多时候为了高效便捷，会引入一个多态的概念<code>（多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作）</code>，而接口就是一个非常能体现多态这一特点的类型。</p>
<p>当我们编写出了不同类型的变量和他们对应的方法，如果这些方法调用过程都非常相似，那么就可以用接口来进行简化。普通函数的缺陷在于他们需要了解参数类型，倘若类型不同是不能互通的。而接口不关心其类型，唯一需要知道的是通过对应方法能做什么。</p>
<h5 id="接口的定义格式："><a href="#接口的定义格式：" class="headerlink" title="接口的定义格式："></a><strong>接口的定义格式：</strong></h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口类型名 <span class="keyword">interface</span>&#123;</span><br><span class="line">    方法名<span class="number">1</span>( 参数列表<span class="number">1</span> ) 返回值列表<span class="number">1</span></span><br><span class="line">    方法名<span class="number">2</span>( 参数列表<span class="number">2</span> ) 返回值列表<span class="number">2</span></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中：</p>
<ul>
<li>接口名：使用<code>type</code>将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加<code>er</code>，如有写操作的接口叫<code>Writer</code>，有字符串功能的接口叫<code>Stringer</code>等。接口名最好要能突出该接口的类型含义。</li>
<li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li>
<li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li>
</ul>
</blockquote>
<p>实现接口指的是什么？就是让一个对象能实现接口中所有的方法，那么这个对象就实现了接口。接口就是一个 <strong>需要实现的方法列表</strong>。</p>
<h5 id="值接收者-VS-指针接收者"><a href="#值接收者-VS-指针接收者" class="headerlink" title="值接收者 VS 指针接收者"></a><strong>值接收者 VS 指针接收者</strong></h5><p>当使用值接收者的方法时，对应接口是 <strong>可以处理值或者对应指针</strong> 的，因为Go语言中有对指针类型变量求值的语法糖，指针内部会自动求值</p>
<p>而如果使用指针接收者，对应接口是 <strong>不能处理普通值类型的变量的</strong>！只能使用指针类型。</p>
<p><strong>一个类型实现多个接口</strong></p>
<p>接口间是相互独立的，只需要把要使用的接口与类型本身对接就可以了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Sayer接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">say</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会叫汪汪汪\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Mover接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s会动\n&quot;</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> x Sayer</span><br><span class="line">	<span class="keyword">var</span> y Mover</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = dog&#123;name: <span class="string">&quot;旺财&quot;</span>&#125;</span><br><span class="line">	x = a</span><br><span class="line">	y = a</span><br><span class="line">	x.say()</span><br><span class="line">	y.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多个类型实现一个接口</strong></p>
<p>除了让不同类型都实现同一个接口，还可以让多个类实现一个接口，接口的方法可以通过在类型中 <strong>嵌入</strong> 其他类型或者结构体来实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WashingMachine 洗衣机</span></span><br><span class="line"><span class="keyword">type</span> WashingMachine <span class="keyword">interface</span> &#123;</span><br><span class="line">	wash()</span><br><span class="line">	dry()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 甩干器</span></span><br><span class="line"><span class="keyword">type</span> dryer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的dry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dryer)</span> <span class="title">dry</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;甩一甩&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 海尔洗衣机</span></span><br><span class="line"><span class="keyword">type</span> haier <span class="keyword">struct</span> &#123;</span><br><span class="line">	dryer <span class="comment">//嵌入甩干器</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现WashingMachine接口的wash()方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h haier)</span> <span class="title">wash</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;洗刷刷&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a><strong>接口嵌套</strong></h5><p>接口间也可以形成包含关系，创造出可以使用不同方法的新接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">	say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">	move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	Sayer</span><br><span class="line">	Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a><strong>空接口</strong></h5><p><em>定义：</em></p>
<p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p>
<p>空接口类型的变量可以存储任意类型的变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;<span class="comment">//空接口可以这样直接声明</span></span><br></pre></td></tr></table></figure>

<p><em>应用：</em></p>
<ul>
<li>作为函数的参数，这样一来函数就可以 <strong>接受任意类型的参数</strong> 了</li>
<li>作为 map 的值，这样一来映射中可以 <strong>保存任何类型的值</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a><strong>接口值</strong></h5><p>一个接口的值（简称接口值）是由 <code>一个具体类型</code> 和 <code>具体类型的值</code> 两部分组成的。这两部分分别称为接口的 <code>动态类型</code> 和 <code>动态值</code>。</p>
<p>想判断空接口包含的值时，可以使用类型断言：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x.(T)<span class="comment">// x:表示空接口的变量</span></span><br><span class="line"><span class="comment">// T:断言 x 可能的类型</span></span><br></pre></td></tr></table></figure>

<p>这样会返回两个值，一个是转化为 T 后的变量，第二个则是 bool 值，若为 <code>true</code> 则表示断言成功，为 <code>false</code> 则表示断言失败。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t,ok:=x.(T)</span><br></pre></td></tr></table></figure>

<p>若 <code>x</code> 保存了一个 <code>T</code>，那么 <code>t</code> 将会是其底层值，而 <code>ok</code> 为 <code>true</code>。</p>
<p>否则，<code>ok</code> 将为 <code>false</code> 而 <code>t</code> 将为 <code>T</code> 类型的零值，程序并不会产生恐慌。</p>
<h5 id="判定一个值的类型还可以使用类型选择："><a href="#判定一个值的类型还可以使用类型选择：" class="headerlink" title="判定一个值的类型还可以使用类型选择："></a>判定一个值的类型还可以使用类型选择：</h5><p>类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch v :&#x3D; i.(type) &#123;</span><br><span class="line">case T:</span><br><span class="line">    &#x2F;&#x2F; v 的类型为 T</span><br><span class="line">case S:</span><br><span class="line">    &#x2F;&#x2F; v 的类型为 S</span><br><span class="line">default:</span><br><span class="line">    &#x2F;&#x2F; 没有匹配，v 与 i 的类型相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型选择中的声明与类型断言 <code>i.(T)</code> 的语法相同，只是具体类型 <code>T</code> 被替换成了关键字 <code>type</code>。</p>
<p>此选择语句判断接口值 <code>i</code> 保存的值类型是 <code>T</code> 还是 <code>S</code>。在 <code>T</code> 或 <code>S</code> 的情况下，变量 <code>v</code> 会分别按 <code>T</code> 或 <code>S</code> 类型保存 <code>i</code> 拥有的值。在默认（即没有匹配）的情况下，变量 <code>v</code> 与 <code>i</code> 的接口类型和值相同。</p>
<h4 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h4><p><code>fmt</code> 包中定义的 <code>Stringer</code> 是最普遍的接口之一。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Stringer</code> 是一个可以用字符串描述自己的类型。<code>fmt</code> 包（还有很多包）都通过此接口来打印值。</p>
<p>意思就是你只需要针对某一类型实现这个方法，就可以直接在 fmt 的很多函数中直接用（比如 Println ，很多 IDE 都会显示函数是否存在接口）。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Go 程序使用 <code>error</code> 值来表示错误状态。</p>
<p>同样，<code>error</code> 类型是一个内建接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以函数在返回值时也默认会返回一个 err 值。一般可以这样获取 err 值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t,err:=math.Sqrt(x)<span class="comment">// err 对应错误值，当其值为 nil 时则没有错误</span></span><br></pre></td></tr></table></figure>

<p>不过既然是接口，当然可以进行一定程度上的自定义，参考之前我们使用接口的经历，先建立类型并让这个类型实现 <code>Error</code> 方法，那么这个时候该类型就可以直接传给 <code>error</code> 接口了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	When time.Time</span><br><span class="line">	What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;at %v, %s&quot;</span>,</span><br><span class="line">		e.When, e.What)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">error</span></span> &#123;	<span class="comment">//将 MyError 直接返回到 error 接口了</span></span><br><span class="line">	<span class="keyword">return</span> &amp;MyError&#123;</span><br><span class="line">		time.Now(),</span><br><span class="line">		<span class="string">&quot; &quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，还有更加简单粗暴快速的方法——那就是<strong>使用 errors.New 函数</strong>，它在 <code>“errors”</code> 包内，使用时直接调用就可以创建并返回一个错误值了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(f), <span class="literal">nil</span></span><br><span class="line">&#125;	<span class="comment">//完全不需要将特殊类型的方法与接口对接</span></span><br></pre></td></tr></table></figure>

<h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p><code>io</code> 包指定了 <code>io.Reader</code> 接口，它表示从数据流的末尾进行读取。</p>
<p>Go 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。</p>
<p><code>io.Reader</code> 接口有一个 <code>Read</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure>

<p><code>Read</code> 用数据 <strong>填充给定的字节切片</strong> 并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 <code>io.EOF</code> 错误。</p>
<p>示例代码创建了一个 <code>strings.Reader</code> 并以每次 8 字节的速度读取它的输出。</p>
<blockquote>
<p>这里有些要补充的是：给定的字节切片填充时是从头开始覆盖，比如原本一个长为4的切片 [1,2,5,7] 填入 2，4 之后之会将前两个元素覆盖而后续不变：[<strong>2,4</strong>,5,7]</p>
</blockquote>
<h4 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h4><p><a href="https://go-zh.org/pkg/image/#Image"><code>image</code></a> 包定义了 <code>Image</code> 接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package image</span><br><span class="line"></span><br><span class="line">type Image interface &#123;</span><br><span class="line">    ColorModel() color.Model</span><br><span class="line">    Bounds() Rectangle</span><br><span class="line">    At(x, y int) color.Color</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong> <code>Bounds</code> 方法的返回值 <code>Rectangle</code> 实际上是一个 <a href="https://go-zh.org/pkg/image/#Rectangle"><code>image.Rectangle</code></a>，它在 <code>image</code> 包中声明。</p>
<p>（请参阅<a href="https://go-zh.org/pkg/image/#Image">文档</a>了解全部信息。）</p>
<p><code>color.Color</code> 和 <code>color.Model</code> 类型也是接口，但是通常因为直接使用预定义的实现 <code>image.RGBA</code> 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由 <a href="https://go-zh.org/pkg/image/color/"><code>image/color</code></a> 包定义。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><p><strong>并行：</strong>同一个时刻，有多条指令在多个处理器上同时执行</p>
<p><strong>并发：</strong>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，通过cpu时间片轮转使多个进程快速交替的执行。</p>
<h4 id="Go-程"><a href="#Go-程" class="headerlink" title="Go 程"></a>Go 程</h4><p>Go 程（goroutine）是由 Go 运行时管理的轻量级线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go f(x, y, z)</span><br></pre></td></tr></table></figure>

<p>会启动一个新的 Go 程并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f(x, y, z)</span><br></pre></td></tr></table></figure>

<p><code>f</code>, <code>x</code>, <code>y</code> 和 <code>z</code> 的求值发生在当前的 Go 程中，而 <code>f</code> 的执行发生在新的 Go 程中。</p>
<p>Go 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。<code>sync</code> 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法</p>
<h4 id="信道-通道（channel）"><a href="#信道-通道（channel）" class="headerlink" title="信道/通道（channel）"></a>信道/通道（channel）</h4><p>顾名思义，就是个带有信息类型的管道，可以通过它用信道操作符 <code>&lt;-</code> 来发送或者接收值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 将 v 发送至信道 ch。</span></span><br><span class="line">i := &lt;-ch  <span class="comment">// 从 ch 接收值并赋予 i，完成了一次信息的传递</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>“箭头”就是数据流的方向。</p>
</blockquote>
<p>和映射与切片一样，信道在使用前必须自己创建：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//使用 make 函数</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，<strong>发送</strong> 和 <strong>接收</strong> 操作在 <strong>另一端准备好之前都会阻塞</strong>。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。（发送方和接收方都可以是多个）</p>
<h5 id="关于传入及传出的死锁问题："><a href="#关于传入及传出的死锁问题：" class="headerlink" title="关于传入及传出的死锁问题："></a>关于传入及传出的死锁问题：</h5><p>在 main 函数下声明的 channel 处于 main goroutine 下运行，它想要接收的一定是 <strong>其它 goroutine 传入的数据</strong>！如果其它 goroutine 都执行完了还没有传入数据，那么就会陷入僵局。这种情况下，等待数据的 main goroutine 只能自杀并且报错给用户。这类错误可以用 <strong>select</strong> 来防止</p>
<h5 id="信道缓冲"><a href="#信道缓冲" class="headerlink" title="信道缓冲"></a>信道缓冲</h5><p>make 函数在声明信道时可以直接将缓冲长度作为第二个参数初始化一个带缓冲的信道。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>发送数据可能出现堵塞：</p>
<p>缓冲区为空：接收方堵塞</p>
<p>缓冲区为满：发送方堵塞</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	ch &lt;- <span class="number">2</span></span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一点：传入缓冲的数据是 <strong>先进先出</strong> 的</p>
<h5 id="range-和-close"><a href="#range-和-close" class="headerlink" title="range 和 close"></a>range 和 close</h5><p>发送者可通过 <code>close</code> 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v, ok :&#x3D; &lt;-ch</span><br></pre></td></tr></table></figure>

<p>之后 <code>ok</code> 会被设置为 <code>false</code>。</p>
<p>循环 <code>for i := range c</code> 会不断从信道接收值，直到它被关闭。</p>
<p><em>注意：</em> 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。</p>
<p><em>还要注意：</em> 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 <code>range</code> 循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x+y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">    <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">    <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">    <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭通道并不会丢失里面的数据，只是让读取通道数据的时候不会读完之后一直阻塞等待新数据写入</p>
<p>Channel 是可以控制读写权限的 具体如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//读写均可的channel c &#125; (a)</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c &lt;- <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//只读的Channel &#125; (a)</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">chan</span> &lt;- <span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//只写的Channel &#125; (a)</span></span><br></pre></td></tr></table></figure>

<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>是 Go 语言中的一种结构，与 switch 十分相似，<strong>每个 case 必须是一个通信操作</strong>，要么是发送要么是接收。</p>
<p>select 随机执行一个可运行的 case。<strong>如果没有 case 可运行，它将阻塞，直到有 case 可运行</strong>。一个默认的子句应该总是可运行的。（为了防止出现死锁的情况，一般会加上 default）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">// 你可以定义任意数量的 case </span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">// 可选 </span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>每个 case 都必须是一个通信</p>
</li>
<li><p>所有 channel 表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果任意某个通信可以进行，它就执行，其他被忽略。</p>
</li>
<li><p>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。</p>
<p>否则：</p>
<ol>
<li>如果有 default 子句，则执行该语句。</li>
<li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li>
</ol>
</li>
</ul>
</blockquote>
<h5 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h5><p>我们已经看到信道非常适合在各个 Go 程间进行通信。</p>
<p>但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？</p>
<p>这里涉及的概念叫做 <em>互斥（mutual exclusion）</em> ，我们通常使用 <em>互斥锁（Mutex）</em> 这一数据结构来提供这种机制。</p>
<p>Go 标准库中提供了 <code>sync.Mutex</code> 互斥锁类型及其两个方法：</p>
<ul>
<li><code>Lock</code></li>
<li><code>Unlock</code></li>
</ul>
<p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。参见 <code>Inc</code> 方法。</p>
<p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法。</p>
<blockquote>
<p><em>草，居然花了这么长时间，果然摸鱼的力量无比强大</em></p>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Go</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>Floyd和Dijsktra的回顾复习</title>
    <url>/2021/08/02/Floyd%E5%92%8CDijsktra%E7%9A%84%E5%9B%9E%E9%A1%BE%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="/2021/08/02/Floyd%E5%92%8CDijsktra%E7%9A%84%E5%9B%9E%E9%A1%BE%E5%A4%8D%E4%B9%A0/cover.JPG" alt="cover"></p>
<p><em>今天心血来潮看了几道最短路径题目，发现自己只记得弗洛伊德算法了，迪杰斯特拉算法忘得比太监的下巴还干净……明明之前还特意看过相关资料的……</em></p>
<span id="more"></span>

<h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><blockquote>
<p>有 n 个网络节点，标记为 1 到 n。</p>
<p>给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。</p>
<p>现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。</p>
<p>示例 1：</p>
<p><img src="https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png" alt="img"></p>
<p>输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2<br>输出：2<br>示例 2：</p>
<p>输入：times = [[1,2,1]], n = 2, k = 1<br>输出：1<br>示例 3：</p>
<p>输入：times = [[1,2,1]], n = 2, k = 2<br>输出：-1</p>
<p>提示：</p>
<p>1 &lt;= k &lt;= n &lt;= 100<br>1 &lt;= times.length &lt;= 6000<br>times[i].length == 3<br>1 &lt;= ui, vi &lt;= n<br>ui != vi<br>0 &lt;= wi &lt;= 100<br>所有 (ui, vi) 对都 互不相同（即，不含重复边）</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/network-delay-time">https://leetcode-cn.com/problems/network-delay-time</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="一、弗洛伊德算法"><a href="#一、弗洛伊德算法" class="headerlink" title="一、弗洛伊德算法"></a>一、弗洛伊德算法</h3><p>弗洛伊德算法实际上被视为一种动态规划，因为其有状态转移方程为：</p>
<p>maplen[i][j]=min(maplen[i][k]+maplen[k][j] , maplen[i][j])</p>
<img src="/2021/08/02/Floyd%E5%92%8CDijsktra%E7%9A%84%E5%9B%9E%E9%A1%BE%E5%A4%8D%E4%B9%A0/1.bmp" alt="1" style="zoom:67%;">

<p>这里 k 是 i 到 j 路径的另一种选择，当 y+z&lt;x 时，最短路径就应该更改为 i-&gt;k-&gt;j。按照这样的理论，我们就可以通过比较找出最短路径。</p>
<p>为了方便我们记录并比较数据，一般会建立一个类似于离散数学中邻接矩阵的二维数组，其中存放各个点之间的路径长度。我们每次对于 i 到 j 之间的路径，将依次插入 1~n 个分支点（即试用所有的已知点来作为 ”k点“，排查最短路径），因此显然时间复杂度高达 O(n<sup>3</sup>) 。为了表示出两点间没有通路，一般把对应的数据填充为 ∞，代码使用 INT_MAX 来达到同样效果</p>
<p>初始化表格就是将现有的直接相连的路径记录在表格上，比如例题中示例一就应该是这样的：</p>
<img src="/2021/08/02/Floyd%E5%92%8CDijsktra%E7%9A%84%E5%9B%9E%E9%A1%BE%E5%A4%8D%E4%B9%A0/2.bmp" alt="2" style="zoom:67%;">

<p>随着后续路径更新，一些间接相连的数据也会记录上去，填充一部分 <strong>∞</strong>。</p>
<p>这道题目中，为了判断是否出现了未完全链接的情况（即从源点无法和部分点形成通路），只需要检测源点对应那一行的状态即可，即全部不为无限长。不过因为只要检测这一行我们却老老实实的打了一整张表，未免有点太不划算了——因此我们请出了 <strong>迪杰斯特拉算法</strong></p>
<h3 id="二、迪杰斯特拉算法"><a href="#二、迪杰斯特拉算法" class="headerlink" title="二、迪杰斯特拉算法"></a>二、迪杰斯特拉算法</h3>]]></content>
      <categories>
        <category>程序算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>题目</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2021/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p><img src="/2021/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/cover.JPG" alt="cover"></p>
<p><em>偶然在别人的作品里面看到使用了正则表达式的地方，就来学习一下以备不时之需。</em></p>
<span id="more"></span>

<blockquote>
<p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p>
<p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>简单示例</strong></p>
<p><code>^[0-9]+abc$</code></p>
<p>其中：</p>
<ul>
<li><strong>^</strong> 为匹配输入字符串的开始位置。</li>
<li><strong>[0-9]+<strong>匹配多个数字， <strong>[0-9]</strong> 匹配单个数字，</strong>+</strong> 匹配一个或者多个（如果不加上”+“就只能匹配一个数字）。</li>
<li><strong>abc$<strong>匹配字母 <strong>abc</strong> 并以 <strong>abc</strong> 结尾，</strong>$</strong> 为匹配输入字符串的结束位置。</li>
</ul>
<p> <code>^</code> 和 <code>$</code> 实际上是俩定位符，用法后面<a href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6">定位符</a>这一节会提到</p>
<p><img src="/2021/07/30/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/eg2.png" alt="eg2"></p>
<blockquote>
<p>以上的正则表达式可以匹配 <strong>runoob、runoob1、run-oob、run_oob</strong>， 但不匹配 <strong>ru</strong>，因为它包含的字母太短了，小于 3 个无法匹配。也不匹配 <strong>runoob$</strong>, 因为它包含特殊字符。</p>
</blockquote>
<h4 id="为什么使用正则表达式？"><a href="#为什么使用正则表达式？" class="headerlink" title="为什么使用正则表达式？"></a>为什么使用正则表达式？</h4><p>在一般的静态文本中进行字符串匹配与搜索使用典型的搜索和替换操作实际上已经足够，但是如果对象是特殊的动态文本，难度会大幅度飙升，这个时候使用正则表达式就会轻松得多（更加灵活）</p>
<p><strong>通过使用正则表达式，可以：</strong></p>
<blockquote>
<ul>
<li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li>
<li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li>
<li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li>
</ul>
</blockquote>
<p>而正则表达式支持的领域是相当广的：C#、Java、JS、Python、Ruby和许多软件、系统都支持正则表达式。</p>
<h3 id="简单语法"><a href="#简单语法" class="headerlink" title="简单语法"></a>简单语法</h3><p>话说回来，正则表达式实际上表达的是一种字符串匹配模式（pattern），可以用来<strong>检查一个串是否含有某种子串</strong>、<strong>将匹配的子串替换</strong> 或者 <strong>从某个串中取出符合某个条件的子串</strong> 等</p>
<blockquote>
<p>例如：</p>
<ul>
<li><strong>runoo+b</strong>，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。</li>
<li><strong>runoo*b</strong>，可以匹配 runob、runoob、runoooooob 等，* 号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li>
<li><strong>colou?r</strong> 可以匹配 color 或者 colour，? 问号代表前面的字符最多只可以出现一次（0次、或1次）。</li>
</ul>
</blockquote>
<p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<hr>
<h4 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h4><p>普通字符包括 <strong>没有显式指定为元字符的所有可打印和不可打印字符</strong>。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[ABC]</td>
<td align="left">匹配 <strong>[…]</strong> 中的所有字符，例如 <strong>[aeiou]</strong> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td>
</tr>
<tr>
<td align="left">[^ABC]</td>
<td align="left">匹配除了 <strong>[…]</strong> 中字符的所有字符，例如 <strong>[^aeiou]</strong> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</td>
</tr>
<tr>
<td align="left">[A-Z]</td>
<td align="left">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除换行符（\n、\r）之外的任何单个字符，相等于  **[^\n\r]**。</td>
</tr>
<tr>
<td align="left">[\s\S]</td>
<td align="left">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">匹配字母、数字、下划线。等价于  <strong>[A-Za-z0-9_]</strong></td>
</tr>
</tbody></table>
<h4 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h4><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\cx</td>
<td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>特殊字符是有特殊含义的字符，一般在正则表达式中有特殊含义或作用，因此如果想将他们变成搜索对象，需要使用转义字符 <code>\</code> 这种老传统。</p>
<table>
<thead>
<tr>
<th align="left">特别字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$</td>
<td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。</td>
</tr>
<tr>
<td align="left">( )</td>
<td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。</td>
</tr>
<tr>
<td align="left">[</td>
<td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 \[。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\“，而 ‘\(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td>
</tr>
<tr>
<td align="left">{</td>
<td align="left">标记限定符表达式的开始。要匹配 {，请使用 \{。</td>
</tr>
<tr>
<td align="left">|</td>
<td align="left">指明两项之间的一个选择。要匹配 |，请使用 \</td>
</tr>
</tbody></table>
<h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p>
<p>正则表达式的限定符有：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<p>以下正则表达式匹配一个正整数，**[1-9]<strong>设置第一个数字不是 0，</strong>[0-9]*** 表示任意多个数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;[1-9][0-9]*&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。</p>
<p>改进下，匹配 1~99 的正整数表达式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;[1-9][0-9]?&#x2F;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;[1-9][0-9]&#123;0,1&#125;&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="贪婪的限定符"><a href="#贪婪的限定符" class="headerlink" title="贪婪的限定符"></a>贪婪的限定符</h4><p>像 ***** 以及 <strong>+</strong> 这类限定符都是贪婪的，原因在于他们会尽可能多的匹配字符，只有在它们后面加上 <strong>？</strong> 才能实现 <strong>非贪婪或最小匹配</strong>。</p>
<p>比如我们使用正则表达式：<code>&lt;.*&gt;</code>  根据定义，它会匹配任意长度的非换行符字符。假设匹配对象为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>have fun searching for the answer<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么由于贪婪性，得到的结果会是 <code>&lt;h1&gt;have fun searching for the answer&lt;/h1&gt;</code> 这一长串内容。</p>
<p>然而当我们加入了 <code>?</code> 实现非贪婪或最小匹配，答案则变成了：<code>&lt;h1&gt;</code> （第一个 h1）</p>
<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><p>很多时候我们使用正则表达式不仅要注意内容，还要对匹配字符的位置做出要求，定位符可以帮助筛选出位置正确的字符。</p>
<p>正则表达式的定位符有：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td align="left">\B</td>
<td align="left">非单词边界匹配。</td>
</tr>
</tbody></table>
<p>这里主要注意的是：</p>
<ul>
<li>限定符不能和定位符一起使用，不要出现 <code>^*</code> 这样的神奇操作</li>
<li>这里的 <code>^</code> 和 <code>$</code> 一定要和之前在中括号表达式中的用途区分开，这里是标记一行文本开头和结尾位置</li>
</ul>
<blockquote>
<p>若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;^Chapter [1-9][0-9]&#123;0,1&#125;&#x2F;</span><br></pre></td></tr></table></figure>

<p>真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它既出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;^Chapter [1-9][0-9]&#123;0,1&#125;$&#x2F;</span><br></pre></td></tr></table></figure>

<p>匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;\bCha&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>\b</strong> 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;ter\b&#x2F;</span><br></pre></td></tr></table></figure>

<p>下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;\Bapt&#x2F;</span><br></pre></td></tr></table></figure>

<p>字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 <strong>\B</strong> 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。</p>
</blockquote>
<p>简单来说，<strong>有 <code>\b</code> 的地方匹配空格符，而有 <code>\B</code> 的地方不能有空格符</strong></p>
<h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4>]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言学习</title>
    <url>/2021/07/28/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>这玩意儿就是写个备忘录，结构拉稀是正常的</p>
<span id="more"></span>

<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a><a href="https://zhuanlan.zhihu.com/c_144694924">入门</a></h3><h4 id="啥是寄存器？"><a href="#啥是寄存器？" class="headerlink" title="啥是寄存器？"></a>啥是寄存器？</h4><p>CPU 中存储计算数据相关信息的地方，CPU 有很多寄存器，帮助记忆计算的数据是什么，是做什么运算。</p>
<h4 id="用-vim-打开一个新文件并写入"><a href="#用-vim-打开一个新文件并写入" class="headerlink" title="用 vim 打开一个新文件并写入"></a>用 vim 打开一个新文件并写入</h4><p>Ubuntu 环境下，首先进入终端界面</p>
<p>然后使用 <code>vim 【文件名.后缀名】</code> 在 vim 中打开新文件</p>
<p>现在是无法输入的，必须按下 <code>i</code> 键进入 <strong>insert</strong> 模式</p>
<p>输入完成后，按下 <code>esc</code> 键退出输入模式</p>
<p>使用 <code>:wq</code> 保存文件</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>发送给 CPU 的一个命令，前提是 CPU 有对应功能</p>
<ul>
<li><h5 id="mov"><a href="#mov" class="headerlink" title="mov"></a>mov</h5></li>
</ul>
<p>数据传送指令，我们可以像下面这样用 <strong>mov</strong> 指令，达到数据传送的目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, 1          ; 让eax的值为1（eax &#x3D; 1）</span><br><span class="line">mov ebx, 2          ; 让ebx的值为2（ebx &#x3D; 2）</span><br><span class="line">mov ecx, eax        ; 把eax的值传送给ecx（ecx &#x3D; eax）</span><br></pre></td></tr></table></figure>

<p>可以将数据送入寄存器，也可以将一个寄存器的数据送到另一个寄存器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">mov ebx, eax</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="add"><a href="#add" class="headerlink" title="add"></a>add</h5></li>
</ul>
<p>加法指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add eax, 2          ; eax &#x3D; eax + 2</span><br><span class="line">add ebx, eax        ; ebx &#x3D; ebx + eax</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h5></li>
</ul>
<p>减法指令（用法和加法指令类似）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub eax, 1              ; eax &#x3D; eax - 1</span><br><span class="line">sub eax, ecx            ; eax &#x3D; eax - ecx</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h5></li>
</ul>
<p>返回指令，类似于 C 语言中的 <strong>return</strong>，用于 <strong>函数调用后的返回</strong></p>
<h4 id="更多寄存器"><a href="#更多寄存器" class="headerlink" title="更多寄存器"></a>更多寄存器</h4><blockquote>
<p>除了前面列举的eax、ebx、ecx、edx之外，还有一些寄存器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">esi</span><br><span class="line">edi</span><br><span class="line">ebp</span><br></pre></td></tr></table></figure>

<p>其中eax、ebx、ecx、edx这四个寄存器是通用寄存器，可以随便存放数据，也能参与到大多数的运算。而余下的三个多见于一些访问内存的场景下，不过，目前，你还是可以随便抓住一个就拿来用的。</p>
</blockquote>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>暂时存放 CPU 计算所需指令和数据的地方。优点是便宜且容量大，但是处理速度比寄存器慢</p>
<h4 id="寄存器中数据转移至内存"><a href="#寄存器中数据转移至内存" class="headerlink" title="寄存器中数据转移至内存"></a>寄存器中数据转移至内存</h4><p>在寄存器中空间不够时，我们会将其数据转移至内存中</p>
<p>同样，我们还是使用 <strong>mov</strong> 指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov [0x5566], eax</span><br></pre></td></tr></table></figure>

<p>最前面那个指令 mov [0x5566], eax 的作用：</p>
<p>将 eax 寄存器的值，保存到编号为 0x5566 对应的内存里去，按照前面的说法，一个 eax 需要 4 个字节的空间才装得下，所以编号为 0x5566 0x5567 0x5568 0x5569 这四个字节都会<strong>被 eax 的某一部分覆盖掉</strong>。</p>
<p>取出时就反着写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, [0x5566] </span><br></pre></td></tr></table></figure>

<h4 id="地址存储练习"><a href="#地址存储练习" class="headerlink" title="地址存储练习"></a>地址存储练习</h4><p>按照上面的示例，很容易就写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    mov ebx, 1</span><br><span class="line">    mov ecx, 2</span><br><span class="line">    add ebx, ecx</span><br><span class="line">    </span><br><span class="line">    mov [0x233], ebx</span><br><span class="line">    mov eax, [0x233]</span><br><span class="line">    </span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>然后程序就挂了……</p>
<p>这是因为程序运行环境处于一个受管控的环境下，不能随便读写内存。需要特殊处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">    mov ebx, 1</span><br><span class="line">    mov ecx, 2</span><br><span class="line">    add ebx, ecx</span><br><span class="line">    </span><br><span class="line">    mov [sui_bian_xie], ebx</span><br><span class="line">    mov eax, [sui_bian_xie]</span><br><span class="line">    </span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">sui_bian_xie   dw    0</span><br></pre></td></tr></table></figure>

<p>与前面那个崩溃的程序相比，后者有一些微小的变化，还多了两行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">sui_bian_xie   dw    0</span><br></pre></td></tr></table></figure>

<p>第一行先不管是表示接下来的内容经过编译后，会放到可执行文件的数据区域，同时也会随着程序启动的时候，<strong>分配对应的内存</strong>。</p>
<p>第二行就是描述真实的数据的关键所在里，这一行的意思是开辟一块 16bits 字节的空间，并且里面用 0 填充。这里的 <strong>dw（define word）定义了16bits的空间</strong>，前面那个 sui_bian_xie 的意思就是这里可以随便写，也就是起个名字而已，方便自己写代码的时候区分，<strong>这个 sui_bian_xie 会在编译时被编译器处理成一个具体的地址</strong>，我们无需理会地址具体时多少，反正知道前后的sui_bian_xie指代的是同一个东西就行了。</p>
<h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><p>使用 gdb 需要指令：<code>gdb ./[编译好的文件名]</code> </p>
<p>启动之后，你会看到终端编程变成这样了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>OK，说明你成功了，接下来输入，并回车：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) set disassembly-flavor intel</span><br></pre></td></tr></table></figure>

<p>这一步是把反汇编的格式 <strong>调整称为 intel 的格式</strong>，稍后完事儿后你可以尝试不用这个设置，看看是什么效果。好了，继续，反汇编，输入命令并回车：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x080483f0 &lt;+0&gt;: mov    eax,0x1</span><br><span class="line">   0x080483f5 &lt;+5&gt;: mov    ebx,0x2</span><br><span class="line">   0x080483fa &lt;+10&gt;:    add    eax,ebx</span><br><span class="line">   0x080483fc &lt;+12&gt;:    ret    </span><br><span class="line">   0x080483fd &lt;+13&gt;:    xchg   ax,ax</span><br><span class="line">   0x080483ff &lt;+15&gt;:    nop</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>好了，整个程序就在这里被反汇编出来了，请你先仔细看一看，是不是和我们写的源代码差不多？（后面多了两行汇编，你把它们当成路人甲看待就行了，不用理它）。</p>
<h5 id="断点操作（下面一大段都是摘得）"><a href="#断点操作（下面一大段都是摘得）" class="headerlink" title="断点操作（下面一大段都是摘得）"></a>断点操作（下面一大段都是摘得）</h5><ul>
<li>断点：程序在运行过程中，当它执行到“断点”对应的这条语句的时候，就会被强行叫停，等着我们把它看个精光，然后再把它放走</li>
<li>注意看反汇编代码，每一行代码的前面都有一串奇怪的数字，这串奇怪的数字指它右边的那条指令在程序运行时的内存中的位置（地址）。注意，指令也是在内存里面的，也有相应的地址。</li>
</ul>
<p>好了，我们开始尝试一下调试功能，首先是设置一个断点，让程序执行到某一个地方就停下来，给我们足够的时间观察。在gdb的命令行中输入：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) break *0x080483f5</span><br></pre></td></tr></table></figure>

<p>后面那串奇怪的数字在不同的环境下可能不一样，你可以结合这里的代码，对照着自己的实际情况修改。（使用反汇编中&lt;+5&gt;所在的那一行前面的数字）</p>
<p>然后我们执行程序：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/vagrant/code/asm/03/test </span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080483f5 in main ()</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>看到了吧，这下程序就被停在了我们设置的断点那个地方，对比着反汇编和你的汇编代码，找一找现在程序是停在哪个位置的吧。run后面提示的内容里，那一串奇怪的数字又出现了，其实这就是我们前面设置断点的那个地址。</p>
<p>好了，到这里，我们就把程序看个精光吧，先看一下eax寄存器的值：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) info register eax</span><br><span class="line">eax            0x1  1</span><br></pre></td></tr></table></figure>

<p>刚好就是1啊，在我们设置断点的那个地方，它的前面一个指令是mov eax, 1，这时候eax的内容就真的变成1了，同样，你还可以看一下ebx：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">info register ebx</span><br><span class="line">ebx            0xf7fce000   -134422528</span><br></pre></td></tr></table></figure>

<p>ebx的值并不是2，这是因为mov ebx, 2这个语句还没有执行，所以暂时你看不到。那我们现在让它执行一下吧：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) stepi</span><br><span class="line">0x080483fa in main ()</span><br></pre></td></tr></table></figure>

<p>好了，输入stepi之后，到这里，程序在我们的控制之下，向后运行了一条指令，也就是刚刚执行了mov ebx, 2，这时候看下ebx：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) info register ebx</span><br><span class="line">ebx            0x2  2</span><br></pre></td></tr></table></figure>

<p>看到了吧，ebx已经变成2了。继续，输入stepi，然后看执行了add指令后的各个寄存器的值：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) stepi</span><br><span class="line">0x080483fc in main ()</span><br><span class="line">(gdb) info register eax</span><br><span class="line">eax            0x3  3</span><br></pre></td></tr></table></figure>

<p>执行完add指令之后，eax跟我们想的一样，变成了3。如果我不知道程序现在停在哪里了，怎么办？很简单，输入disas之后，又能看到反汇编了，同时gdb还会标记出当前断点所在的位置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) disas</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">   0x080483f0 &lt;+0&gt;: mov    eax,0x1</span><br><span class="line">   0x080483f5 &lt;+5&gt;: mov    ebx,0x2</span><br><span class="line">   0x080483fa &lt;+10&gt;:    add    eax,ebx</span><br><span class="line">=&gt; 0x080483fc &lt;+12&gt;:    ret    </span><br><span class="line">   0x080483fd &lt;+13&gt;:    xchg   ax,ax</span><br><span class="line">   0x080483ff &lt;+15&gt;:    nop</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>

<p>现在刚好就在add执行过后的ret那个地方。这时候，如果你不想玩了，可以输入continue，让程序自由地飞翔起来，直到GG。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">[Inferior 1 (process 1283) exited with code 03]</span><br></pre></td></tr></table></figure>

<p>看到了吧，程序已经GG了，而且返回了一个数字03。这刚好就是那个eax寄存器的值嘛。</p>
]]></content>
      <categories>
        <category>Bin</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>面对对象</tag>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言常用标准库</title>
    <url>/2021/08/14/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/</url>
    <content><![CDATA[<p><img src="/2021/08/14/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/c.png" alt="c"></p>
<span id="more"></span>

<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="文件的打开："><a href="#文件的打开：" class="headerlink" title="文件的打开："></a>文件的打开：</h4><p>使用 <code>os.Open()</code> 函数可以打开一个文件返回一个<code>*File</code>和一个<code>err</code>。相对的，使用 <code>[文件对象].Close()</code> 可以关闭对应文件</p>
<blockquote>
<p>注：为防止忘记关闭文件，一般我们会加上 defer 推迟语句保证执行后关闭</p>
</blockquote>
<h4 id="读取文件："><a href="#读取文件：" class="headerlink" title="读取文件："></a>读取文件：</h4><h5 id="1、使用-read-方法"><a href="#1、使用-read-方法" class="headerlink" title="1、使用 read 方法"></a>1、使用 read 方法</h5><p>Read方法定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回 <code>0</code> 和 <code>io.EOF</code>。 </p>
<p>需要传入的参数是一个字节切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read1</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	obj,err:=os.Open(<span class="string">&quot;./jk.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file failed,err:&quot;</span>,err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> obj.Close()</span><br><span class="line">	<span class="keyword">var</span> s [<span class="number">2000</span>]<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := obj.Read(s[:])</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;文件读取结束&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;错误！err:&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(s[:n]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、使用-bufio-方法"><a href="#2、使用-bufio-方法" class="headerlink" title="2、使用 bufio 方法"></a>2、使用 bufio 方法</h5><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bufio&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufio按行读取示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.Open(<span class="string">&quot;./xx.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewReader(file)<span class="comment">//从文件生成读对象</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//注意是字符</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">				fmt.Println(line)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件读完了&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;read file failed, err:&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Print(line)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、使用-ioutil-直接读取整个文件"><a href="#3、使用-ioutil-直接读取整个文件" class="headerlink" title="3、使用 ioutil 直接读取整个文件"></a>3、使用 ioutil 直接读取整个文件</h5><blockquote>
<p>（很消耗内存，大文件读取不推荐）</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ret,err:=ioutil.ReadFile(<span class="string">&quot;./jk.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;错误！err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(ret))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文件写入操作："><a href="#文件写入操作：" class="headerlink" title="文件写入操作："></a>文件写入操作：</h4><p>首先我们需要认识 <code>os.OpenFile</code> 这个新函数，它的定义是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span></span><br></pre></td></tr></table></figure>

<p>传入参数中，<strong>name</strong> 指的是要打开的文件名字，<strong>flag</strong> 指打开文件的模式，主要有以下几种：</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>os.O_WRONLY</code></td>
<td align="center">只写</td>
</tr>
<tr>
<td align="center"><code>os.O_CREATE</code></td>
<td align="center">创建文件</td>
</tr>
<tr>
<td align="center"><code>os.O_RDONLY</code></td>
<td align="center">只读</td>
</tr>
<tr>
<td align="center"><code>os.O_RDWR</code></td>
<td align="center">读写</td>
</tr>
<tr>
<td align="center"><code>os.O_TRUNC</code></td>
<td align="center">清空</td>
</tr>
<tr>
<td align="center"><code>os.O_APPEND</code></td>
<td align="center">追加</td>
</tr>
</tbody></table>
<p>当需要进行多种操作时，只需要用 “|” 连接（毕竟都是 int 值）</p>
<p>这个 <strong>perm</strong> 倒是看上去莫名其妙的，实际上这里装的是一个关系权限的八进制数，可以通过这个函数获取结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := os.FileMode(<span class="number">0666</span>).String()</span><br></pre></td></tr></table></figure>

<p>得出 <code>-rw-rw-rw-</code> 的答案：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">一般文件属性标识如下： </span><br><span class="line"></span><br><span class="line">-rwxrwxrwx</span><br><span class="line"></span><br><span class="line">第<span class="number">1</span>位：文件属性，一般常用的是<span class="string">&quot;-&quot;</span>，表示是普通文件；<span class="string">&quot;d&quot;</span>表示是一个目录。</span><br><span class="line"></span><br><span class="line">第<span class="number">2</span>～<span class="number">4</span>位：文件所有者的权限rwx (可读/可写/可执行)。</span><br><span class="line"></span><br><span class="line">第<span class="number">5</span>～<span class="number">7</span>位：文件所属用户组的权限rwx (可读/可写/可执行)。</span><br><span class="line"></span><br><span class="line">第<span class="number">8</span>～<span class="number">10</span>位：其他人的权限rwx (可读/可写/可执行)。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">在golang中，可以使用os.FileMode(perm).String()来查看权限标识：</span><br><span class="line"></span><br><span class="line">os.FileMode(<span class="number">0777</span>).String()    <span class="comment">//返回 -rwxrwxrwx</span></span><br><span class="line"></span><br><span class="line">os.FileMode(<span class="number">0666</span>).String()   <span class="comment">//返回 -rw-rw-rw-</span></span><br><span class="line"></span><br><span class="line">os.FileMode(<span class="number">0644</span>).String()   <span class="comment">//返回 -rw-r--r--</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="number">0777</span>表示：创建了一个普通文件，所有人拥有所有的读、写、执行权限</span><br><span class="line"></span><br><span class="line"><span class="number">0666</span>表示：创建了一个普通文件，所有人拥有对该文件的读、写权限，但是都不可执行</span><br><span class="line"></span><br><span class="line"><span class="number">0644</span>表示：创建了一个普通文件，文件所有者对该文件有读写权限，用户组和其他人只有读权限，</span><br><span class="line">都没有执行权限</span><br></pre></td></tr></table></figure>

<p>然后和读取相对的，写入也有三种不同的方法：</p>
<h5 id="1、使用-Write-和-WriteString"><a href="#1、使用-Write-和-WriteString" class="headerlink" title="1、使用 Write 和 WriteString"></a>1、使用 Write 和 WriteString</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;hw.txt&quot;</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	file.Write([]<span class="keyword">byte</span>(str))       <span class="comment">//写入字节切片数据</span></span><br><span class="line">	file.WriteString(<span class="string">&quot;hello world&quot;</span>) <span class="comment">//直接写入字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、bufio-NewWriter"><a href="#2、bufio-NewWriter" class="headerlink" title="2、bufio.NewWriter"></a>2、bufio.NewWriter</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;hw.txt&quot;</span>, os.O_CREATE|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open file failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	writer := bufio.NewWriter(file)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		writer.WriteString(<span class="string">&quot;hello world\n&quot;</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line">	&#125;</span><br><span class="line">	writer.Flush() <span class="comment">//将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，会循环写入十次 “hello world” 而只需要一次 Flush</p>
<h5 id="3、ioutil-WriteFile"><a href="#3、ioutil-WriteFile" class="headerlink" title="3、ioutil.WriteFile"></a>3、ioutil.WriteFile</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	err := ioutil.WriteFile(<span class="string">&quot;./hw.txt&quot;</span>, []<span class="keyword">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;write file failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个用法自带清场效果，慎用</p>
<h3 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h3><p>有些类似于 iostream 这些输入输出流的库，实现了类似C语言 printf 和 scanf 的格式化 I/O。主要分为向外输出内容和获取输入内容两大部分。</p>
<h4 id="Print-系列"><a href="#Print-系列" class="headerlink" title="Print 系列"></a>Print 系列</h4><p>相关定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Print</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p>print 直接输出内容，Printf 支持<a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8D%A0%E4%BD%8D%E7%AC%A6">格式化</a>输出字符串（%d，%s…）与 C 中用法类似，而 Println 和 Print 相似，只不过输出后会自动换行。</p>
<p>可以看到他们都可以自定义接口，详见之前的 Go 语言入门。</p>
<h4 id="Fprint"><a href="#Fprint" class="headerlink" title="Fprint"></a>Fprint</h4><p>定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprint</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fprintln</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p><code>Fprint</code> 系列函数会将内容输出到一个 <code>io.Writer</code> 接口类型的变量 <code>w</code> 中，我们通常用这个函数往文件中写入内容。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向标准输出写入内容</span></span><br><span class="line">fmt.Fprintln(os.Stdout, <span class="string">&quot;向标准输出写入内容&quot;</span>)</span><br><span class="line">fileObj, err := os.OpenFile(<span class="string">&quot;./hw.txt&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;打开文件出错，err:&quot;</span>, err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">n := <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="comment">// 向打开的文件句柄中写入内容</span></span><br><span class="line">fmt.Fprintf(fileObj, <span class="string">&quot;往文件中写入信息：%s&quot;</span>, n)</span><br></pre></td></tr></table></figure>

<p><strong>只要满足 <code>io.Writer</code> 接口类型，都可以写入</strong></p>
<h4 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h4><p>定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprint</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sprintln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">string</span></span></span><br></pre></td></tr></table></figure>

<p>这个函数主要是用来转字符串的，它可以将传入数据转化成字符串，传入数据格式和 Print 类是一样的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">比如 str:=Sprint(<span class="string">&quot;hello world!&quot;</span>) 此时 str 中存储的就是 “hello world!”</span><br></pre></td></tr></table></figure>

<h4 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h4><p><code>Errorf</code>函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>通常使用这种方式来自定义错误类型，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err := fmt.Errorf(<span class="string">&quot;这是一个错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Go1.13版本为<code>fmt.Errorf</code>函数新加了一个<code>%w</code>占位符用来生成一个可以包裹Error的Wrapping Error。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := errors.New(<span class="string">&quot;原始错误e&quot;</span>)</span><br><span class="line">w := fmt.Errorf(<span class="string">&quot;Wrap了一个错误%w&quot;</span>, e)</span><br></pre></td></tr></table></figure>

<h4 id="格式化占位符"><a href="#格式化占位符" class="headerlink" title="格式化占位符"></a>格式化占位符</h4><p><a href="#%E8%8E%B7%E5%8F%96%E8%BE%93%E5%85%A5">点击跳过</a></p>
<p><code>*printf</code> 系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。</p>
<blockquote>
<h5 id="通用占位符"><a href="#通用占位符" class="headerlink" title="通用占位符"></a>通用占位符</h5><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%v</td>
<td align="center">值的默认格式表示</td>
</tr>
<tr>
<td align="center">%+v</td>
<td align="center">类似%v，但输出结构体时会添加字段名</td>
</tr>
<tr>
<td align="center">%#v</td>
<td align="center">值的Go语法表示</td>
</tr>
<tr>
<td align="center">%T</td>
<td align="center">打印值的类型</td>
</tr>
<tr>
<td align="center">%%</td>
<td align="center">百分号</td>
</tr>
</tbody></table>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="number">100</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">o := <span class="keyword">struct</span>&#123; name <span class="keyword">string</span> &#125;&#123;<span class="string">&quot;小王子&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, o)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, o)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, o)</span><br><span class="line">fmt.Printf(<span class="string">&quot;100%%\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&#123;小王子&#125;</span><br><span class="line">struct &#123; name string &#125;&#123;name:<span class="string">&quot;小王子&quot;</span>&#125;</span><br><span class="line">struct &#123; name string &#125;</span><br><span class="line">100%</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h5 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h5><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%t</td>
<td align="center">true或false</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%b</td>
<td align="center">表示为二进制</td>
</tr>
<tr>
<td align="center">%c</td>
<td align="center">该值对应的unicode码值</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">表示为十进制</td>
</tr>
<tr>
<td align="center">%o</td>
<td align="center">表示为八进制</td>
</tr>
<tr>
<td align="center">%x</td>
<td align="center">表示为十六进制，使用a-f</td>
</tr>
<tr>
<td align="center">%X</td>
<td align="center">表示为十六进制，使用A-F</td>
</tr>
<tr>
<td align="center">%U</td>
<td align="center">表示为Unicode格式：U+1234，等价于”U+%04X”</td>
</tr>
<tr>
<td align="center">%q</td>
<td align="center">该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示</td>
</tr>
</tbody></table>
</blockquote>
<p>进制转换倒是挺方便</p>
<blockquote>
<h5 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h5><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%b</td>
<td align="center">无小数部分、二进制指数的科学计数法，如-123456p-78</td>
</tr>
<tr>
<td align="center">%e</td>
<td align="center">科学计数法，如-1234.456e+78</td>
</tr>
<tr>
<td align="center">%E</td>
<td align="center">科学计数法，如-1234.456E+78</td>
</tr>
<tr>
<td align="center">%f</td>
<td align="center">有小数部分但无指数部分，如123.456</td>
</tr>
<tr>
<td align="center">%F</td>
<td align="center">等价于%f</td>
</tr>
<tr>
<td align="center">%g</td>
<td align="center">根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</td>
</tr>
<tr>
<td align="center">%G</td>
<td align="center">根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</td>
</tr>
</tbody></table>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="number">12.34</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%e\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%E\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%g\n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%G\n&quot;</span>, f)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6946802425218990p-49</span><br><span class="line">1.234000e+01</span><br><span class="line">1.234000E+01</span><br><span class="line">12.340000</span><br><span class="line">12.34</span><br><span class="line">12.34</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h5 id="字符串和-byte"><a href="#字符串和-byte" class="headerlink" title="字符串和[]byte"></a>字符串和[]byte</h5><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%s</td>
<td align="center">直接输出字符串或者[]byte</td>
</tr>
<tr>
<td align="center">%q</td>
<td align="center">该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示</td>
</tr>
<tr>
<td align="center">%x</td>
<td align="center">每个字节用两字符十六进制数表示（使用a-f</td>
</tr>
<tr>
<td align="center">%X</td>
<td align="center">每个字节用两字符十六进制数表示（使用A-F）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%p</td>
<td align="center">表示为十六进制，并加上前导的0x</td>
</tr>
</tbody></table>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#p\n&quot;</span>, &amp;a)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0xc000094000</span><br><span class="line">c000094000</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h5 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h5><p>宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下：</p>
<table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%f</td>
<td align="center">默认宽度，默认精度</td>
</tr>
<tr>
<td align="center">%9f</td>
<td align="center">宽度9，默认精度</td>
</tr>
<tr>
<td align="center">%.2f</td>
<td align="center">默认宽度，精度2</td>
</tr>
<tr>
<td align="center">%9.2f</td>
<td align="center">宽度9，精度2</td>
</tr>
<tr>
<td align="center">%9.f</td>
<td align="center">宽度9，精度0</td>
</tr>
</tbody></table>
<p>示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n := <span class="number">12.34</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%.2f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9.2f\n&quot;</span>, n)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%9.f\n&quot;</span>, n)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">12.340000</span><br><span class="line">12.340000</span><br><span class="line">12.34</span><br><span class="line">    12.34</span><br><span class="line">       12</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<h5 id="其他flag"><a href="#其他flag" class="headerlink" title="其他flag"></a>其他flag</h5><table>
<thead>
<tr>
<th align="center">占位符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">’+’</td>
<td align="center">总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）；</td>
</tr>
<tr>
<td align="center">’ ‘</td>
<td align="center">对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格</td>
</tr>
<tr>
<td align="center">’-’</td>
<td align="center">在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）；</td>
</tr>
<tr>
<td align="center">’#’</td>
<td align="center">八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值；</td>
</tr>
<tr>
<td align="center">‘0’</td>
<td align="center">使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面；</td>
</tr>
</tbody></table>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;小王子&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%-5s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%-5.7s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%5.2s\n&quot;</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%05s\n&quot;</span>, s)</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">小王子</span><br><span class="line">  小王子</span><br><span class="line">小王子  </span><br><span class="line">  小王子</span><br><span class="line">小王子  </span><br><span class="line">   小王</span><br><span class="line">00小王子</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="获取输入"><a href="#获取输入" class="headerlink" title="获取输入"></a>获取输入</h4><h5 id="fmt-Scan"><a href="#fmt-Scan" class="headerlink" title="fmt.Scan"></a>fmt.Scan</h5><p>定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scan</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。</li>
<li>需要使用 ‘&amp;’ 取址</li>
</ul>
<h5 id="fmt-Scanf"><a href="#fmt-Scanf" class="headerlink" title="fmt.Scanf"></a>fmt.Scanf</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<p> 由上面的代码看到，string 之前有一个 “format” ，说明需要适当的格式化输入。可类比 Printf</p>
<p>同样，读入时也是按空白符分割。</p>
<h5 id="fmt-Scanln"><a href="#fmt-Scanln" class="headerlink" title="fmt.Scanln"></a>fmt.Scanln</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Scanln</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</li>
<li>本函数返回成功扫描的数据个数和遇到的任何错误。</li>
</ul>
<h5 id="bufio-NewReader"><a href="#bufio-NewReader" class="headerlink" title="bufio.NewReader"></a>bufio.NewReader</h5><p>之前在读取文件时，用到了 bufio，其实在读取用户输入时，为了获取包含空格的内容，bufio 也十分管用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bufioDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	reader := bufio.NewReader(os.Stdin) <span class="comment">// 从标准输入生成读对象</span></span><br><span class="line">	fmt.Print(<span class="string">&quot;请输入内容：&quot;</span>)</span><br><span class="line">	text, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">// 读到换行</span></span><br><span class="line">	text = strings.TrimSpace(text)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Fscan系列"><a href="#Fscan系列" class="headerlink" title="Fscan系列"></a>Fscan系列</h5><p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从<code>io.Reader</code>中读取数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscan</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanln</span><span class="params">(r io.Reader, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fscanf</span><span class="params">(r io.Reader, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="Sscan系列"><a href="#Sscan系列" class="headerlink" title="Sscan系列"></a>Sscan系列</h5><p>这几个函数功能分别类似于<code>fmt.Scan</code>、<code>fmt.Scanf</code>、<code>fmt.Scanln</code>三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscan</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanln</span><span class="params">(str <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sscanf</span><span class="params">(str <span class="keyword">string</span>, format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="time-包"><a href="#time-包" class="headerlink" title="time 包"></a>time 包</h3><h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><p>time.Time 类型表示时间。可以通过 time.Now() 获取当前时间，而具体时间也有相关获取函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>time.Year()</td>
<td>获取年</td>
</tr>
<tr>
<td>time.Month()</td>
<td>获取月</td>
</tr>
<tr>
<td>time.Day()</td>
<td>获取日</td>
</tr>
<tr>
<td>time.Hour()</td>
<td>获取时</td>
</tr>
<tr>
<td>time.Minute()</td>
<td>获取分</td>
</tr>
<tr>
<td>time.Second()</td>
<td>获取秒</td>
</tr>
</tbody></table>
<p>Go 的时间库算是比较强大了，毕竟甚至可以进行 Tues+1==Wed 这样的运算</p>
<h4 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h4><p>时间戳是自1970年1月1日（08:00:00GMT）至当前时间的总毫秒数。它也被称为Unix时间戳（UnixTimestamp）。</p>
<p>同样，对应时间类型，只需要 <strong><code>.Unix</code> 获取时间戳或者用 <code>.Unixnano</code> 获取纳秒时间戳即可</strong></p>
<p>值得注意的是，时间戳格式还可以重新换成时间格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timeObj := time.Unix(timestamp, <span class="number">0</span>) <span class="comment">//将时间戳转为时间格式</span></span><br></pre></td></tr></table></figure>

<p>这个函数里面的两个参数分别对应时间戳和纳秒时间戳，通常将目标以外的 <strong>另一个参数置零</strong></p>
<h4 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h4><p><code>time.Duration</code>是<code>time</code>包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。<code>time.Duration</code>表示一段时间间隔，可表示的最长时间段大约290年。</p>
<p>time包中定义的时间间隔类型的常量如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Nanosecond  Duration = <span class="number">1</span></span><br><span class="line">    Microsecond          = <span class="number">1000</span> * Nanosecond</span><br><span class="line">    Millisecond          = <span class="number">1000</span> * Microsecond</span><br><span class="line">    Second               = <span class="number">1000</span> * Millisecond</span><br><span class="line">    Minute               = <span class="number">60</span> * Second</span><br><span class="line">    Hour                 = <span class="number">60</span> * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>例如：<code>time.Duration</code>表示1纳秒，<code>time.Second</code>表示1秒。</p>
<h4 id="时间操作"><a href="#时间操作" class="headerlink" title="时间操作"></a>时间操作</h4><img src="/2021/08/14/Go%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93/time.bmp" alt="time" style="zoom: 40%;">

<p>有时候我们需要进行一些时间操作，这个时候 Go 语言丰富的方法就为我们提供了便捷。</p>
<h5 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h5><p>我们在日常的编码过程中可能会遇到要求时间+时间间隔的需求，Go语言的时间对象有提供Add方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span></span><br></pre></td></tr></table></figure>

<p>即对任意 Time 类型参数 t ，都可以使用 <strong><code>t.Add(间隔时间参数)</code></strong> 得到增加后的时间数据。</p>
<p><em>另外，如果是想进行减去时间间隔的运算，只需要将参数 d 设置为对应负数即可。</em></p>
<h5 id="Sub"><a href="#Sub" class="headerlink" title="Sub"></a>Sub</h5><p>求两个时间之间的差值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Sub</span><span class="params">(u Time)</span> <span class="title">Duration</span></span></span><br></pre></td></tr></table></figure>

<p>返回一个时间段 **t-u (顺序调换会异号)**。如果结果超出了Duration可以表示的最大值/最小值，将返回最大值/最小值。</p>
<h5 id="Equal"><a href="#Equal" class="headerlink" title="Equal"></a>Equal</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Equal</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>判断两个时间是否相同，会考虑时区的影响，因此 <strong>不同时区标准的时间也可以正确比较</strong>。本方法和用 <code>t==u</code> 不同，这种方法还会比较地点和时区信息。</p>
<h5 id="Before-After"><a href="#Before-After" class="headerlink" title="Before/After"></a>Before/After</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Before</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>如果t代表的时间点在u之前，返回真；否则返回假。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">After</span><span class="params">(u Time)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>如果t代表的时间点在u之后，返回真；否则返回假。</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>使用 <code>time.Tick(时间间隔)</code> 来设置定时器，定时器的 <strong>本质上是一个通道（channel）</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tickDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ticker := time.Tick(time.Second) <span class="comment">//定义一个1秒间隔的定时器</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> ticker &#123;</span><br><span class="line">		fmt.Println(i)<span class="comment">//每秒都会执行的任务</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过既然是定时器，配套设施也很多，比如我们的 <code>time.Sleep()</code> 和它的完全体 <code>time.NewTicker()</code> 。</p>
<p>time.Sleep() 主要提供一个进程休眠的过程，而 Tick（）本身就 <strong>只是一个相对残缺的部分</strong>，它只传回一个 channel，而 time.NewTicker() 则提供了包含关闭 Ticker 的方法，在需要回收的情况下更合适。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   boomer:=time.NewTicker(time.Second)</span><br><span class="line">   <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">for</span> _=<span class="keyword">range</span> boomer.C&#123;</span><br><span class="line">         fmt.Println(<span class="string">&quot;di...&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;()</span><br><span class="line"></span><br><span class="line">   time.Sleep(time.Second*<span class="number">5</span>)</span><br><span class="line">   boomer.Stop()<span class="comment">//终止 boomer 的行为</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">&quot;Booooooom!!!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h4><p>Time 类型拥有一个 <code>Format</code> 方法来进行格式化，然而 Go 语言毕竟是人家大公司的作品，连个格式化都要搞一手致敬——它的格式化模板不是常见的 <code>Y-m-d H:M:S</code> ，而是使用Go的诞生时间2006年1月2号15点04分。</p>
<blockquote>
<p><strong>注：想格式化为12小时类型的化，还需指定<code>PM</code>。</strong></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">formatDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	now := time.Now()</span><br><span class="line">	<span class="comment">// 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan</span></span><br><span class="line">	<span class="comment">// 24小时制</span></span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;2006-01-02 15:04:05.000 Mon Jan&quot;</span>))</span><br><span class="line">	<span class="comment">// 12小时制</span></span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;2006-01-02 03:04:05.000 PM Mon Jan&quot;</span>))</span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;2006/01/02 15:04&quot;</span>))</span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;15:04 2006/01/02&quot;</span>))</span><br><span class="line">	fmt.Println(now.Format(<span class="string">&quot;2006/01/02&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解析字符串格式的时间"><a href="#解析字符串格式的时间" class="headerlink" title="解析字符串格式的时间"></a>解析字符串格式的时间</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)</span><br><span class="line"><span class="comment">// 加载时区</span></span><br><span class="line">loc, err := time.LoadLocation(<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照指定时区和指定格式解析字符串时间</span></span><br><span class="line">timeObj, err := time.ParseInLocation(<span class="string">&quot;2006/01/02 15:04:05&quot;</span>, <span class="string">&quot;2019/08/04 14:15:20&quot;</span>, loc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(timeObj)</span><br><span class="line">fmt.Println(timeObj.Sub(now))</span><br></pre></td></tr></table></figure>

<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><p>Go语言内置的<code>log</code>包实现了简单的日志服务。本文介绍了标准库<code>log</code>的基本使用。</p>
<h4 id="使用Logger"><a href="#使用Logger" class="headerlink" title="使用Logger"></a>使用Logger</h4><blockquote>
<p>log 包定义了 Logger 类型，该类型提供了一些格式化输出的方法。本包也提供了一个预定义的“标准” logger，可以通过调用函数 <code>Print系列</code>(Print|Printf|Println）、<code>Fatal系列</code>（Fatal|Fatalf|Fatalln）、和 <code>Panic系列</code>（Panic|Panicf|Panicln）来使用，比自行创建一个 logger 对象更容易使用。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">//log.Fatalln(&quot;this is a piece of diary which can cause fatal&quot;)</span></span><br><span class="line">   <span class="comment">//log.Panicln(&quot;this is a piece of diary which can cause panic&quot;)</span></span><br><span class="line">   log.Println(<span class="string">&quot;this is a piece of diary which is really normal&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++ &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;hey!&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>logger 会打印每条日志信息的日期、时间，默认输出到系统的标准错误。Fatal 系列函数会在写入日志信息后调用 os.Exit(1)。Panic 系列函数会在写入日志信息后 panic。</p>
<blockquote>
<p>os.Exit(1)：指非正常运行导致退出程序</p>
<p>os.Exit(0)：正常运行导致退出程序</p>
</blockquote>
<p>fatal 以及 panic 触发后，后续语句都不会执行。</p>
<h4 id="配置logger"><a href="#配置logger" class="headerlink" title="配置logger"></a>配置logger</h4><p>默认情况下只会让 log 返回一部分时间信息，要是我们想获取更多信息该怎么办呢？</p>
<p><code>log</code> 标准库中的 <code>Flags</code> 函数会返回标准logger的输出配置，而 <code>SetFlags</code> 函数用来设置标准 logger 的输出配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Flags</span><span class="params">()</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetFlags</span><span class="params">(flag <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="flag选项"><a href="#flag选项" class="headerlink" title="flag选项"></a>flag选项</h5><p>通过 flag 可以选择输出配置，他们是一系列定义好的常量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// 控制输出日志信息的细节，不能控制输出的顺序和格式。</span></span><br><span class="line">    <span class="comment">// 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</span></span><br><span class="line">    Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// 日期：2009/01/23</span></span><br><span class="line">    Ltime                         <span class="comment">// 时间：01:23:23</span></span><br><span class="line">    Lmicroseconds                 <span class="comment">// 微秒级别的时间：01:23:23.123123（用于增强Ltime位）</span></span><br><span class="line">    Llongfile                     <span class="comment">// 文件全路径名+行号： /a/b/c/d.go:23</span></span><br><span class="line">    Lshortfile                    <span class="comment">// 文件名+行号：d.go:23（会覆盖掉Llongfile）</span></span><br><span class="line">    LUTC                          <span class="comment">// 使用UTC时间</span></span><br><span class="line">    LstdFlags     = Ldate | Ltime <span class="comment">// 标准logger的初始值</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>使用 log.SetFlags() 设置标准logger的输出</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="配置日志前缀"><a href="#配置日志前缀" class="headerlink" title="配置日志前缀"></a>配置日志前缀</h5><p>类比我们的 Flag，前缀使用 Prefix 表示，<code>log</code>标准库中还提供了关于日志信息前缀的两个方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Prefix</span><span class="params">()</span> <span class="title">string</span>//查看 <span class="title">logger</span> 的输出前缀</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetPrefix</span><span class="params">(prefix <span class="keyword">string</span>)</span>//用来设置 <span class="title">logger</span> 的输出前缀</span></span><br></pre></td></tr></table></figure>

<p>这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。</p>
<h5 id="配置日志输出位置"><a href="#配置日志输出位置" class="headerlink" title="配置日志输出位置"></a>配置日志输出位置</h5><p><code>SetOutput</code> 函数用来设置标准 logger 的输出目的地，<strong>默认是标准错误输出</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetOutput</span><span class="params">(w io.Writer)</span></span></span><br></pre></td></tr></table></figure>

<p>看见 io.Writer 就知道可能要用 os.OpenFile 了，这里设定是将日志输出到对应文件（不过你用 os.stdout 也没毛病）</p>
<p>如果你要使用标准的logger，我们通常会把配置操作写到<code>init</code>函数中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logFile, err := os.OpenFile(<span class="string">&quot;./xx.log&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;open log file failed, err:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	log.SetOutput(logFile)</span><br><span class="line">	log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建logger"><a href="#创建logger" class="headerlink" title="创建logger"></a>创建logger</h4><p><code>log</code> 标准库中还提供了一个创建新 logger 对象的构造函数– <code>New</code>，支持我们创建自己的 logger 示例。<code>New </code> 函数的签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="keyword">string</span>, flag <span class="keyword">int</span>)</span> *<span class="title">Logger</span></span></span><br></pre></td></tr></table></figure>

<p>New 创建一个 Logger 对象。其中，参数 out 设置日志信息写入的目的地。参数 prefix 会添加到生成的每一条日志前面。参数 flag 定义日志的属性（时间、文件等等）。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logger := log.New(os.Stdout, <span class="string">&quot;&lt;New&gt;&quot;</span>, log.Lshortfile|log.Ldate|log.Ltime)</span><br><span class="line">	logger.Println(<span class="string">&quot;这是自定义的 logger 记录的日志。&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码编译执行之后，得到结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;New&gt;2017/06/19 14:06:51 main.go:34: 这是自定义的 logger 记录的日志。</span><br></pre></td></tr></table></figure>

<h3 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a>net/http</h3><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
<h4 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h4><h5 id="基本的HTTP-HTTPS请求"><a href="#基本的HTTP-HTTPS请求" class="headerlink" title="基本的HTTP/HTTPS请求"></a>基本的HTTP/HTTPS请求</h5><p>Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line">...</span><br><span class="line">resp, err := http.Post(<span class="string">&quot;http://example.com/upload&quot;</span>, <span class="string">&quot;image/jpeg&quot;</span>, &amp;buf)</span><br><span class="line">...</span><br><span class="line">resp, err := http.PostForm(<span class="string">&quot;http://example.com/form&quot;</span>,</span><br><span class="line">	url.Values&#123;<span class="string">&quot;key&quot;</span>: &#123;<span class="string">&quot;Value&quot;</span>&#125;, <span class="string">&quot;id&quot;</span>: &#123;<span class="string">&quot;123&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>程序在使用完response后必须关闭回复的主体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;http://example.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Go</tag>
        <tag>工作</tag>
      </tags>
  </entry>
</search>
